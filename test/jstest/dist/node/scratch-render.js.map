{"version":3,"file":"scratch-render.js","sources":["webpack://ScratchRender/webpack/bootstrap","webpack://ScratchRender/external \"grapheme-breaker\"","webpack://ScratchRender/external \"linebreak\"","webpack://ScratchRender/./node_modules/microee/index.js","webpack://ScratchRender/./node_modules/minilog/lib/common/filter.js","webpack://ScratchRender/./node_modules/minilog/lib/common/minilog.js","webpack://ScratchRender/./node_modules/minilog/lib/common/transform.js","webpack://ScratchRender/./node_modules/minilog/lib/index.js","webpack://ScratchRender/./node_modules/minilog/lib/node/console.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/clean.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/color.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/learnboost.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/minilog.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/npm.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/time.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/util.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/withstack.js","webpack://ScratchRender/./node_modules/minilog/lib/node/redis.js","webpack://ScratchRender/./node_modules/minilog/lib/node/stringify.js","webpack://ScratchRender/./node_modules/minilog/lib/web/console.js","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/color.js","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/minilog.js","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/util.js","webpack://ScratchRender/./src/shaders/sprite.frag","webpack://ScratchRender/./src/shaders/sprite.vert","webpack://ScratchRender/src/BitmapSkin.js","webpack://ScratchRender/src/Drawable.js","webpack://ScratchRender/src/EffectTransform.js","webpack://ScratchRender/src/PenSkin.js","webpack://ScratchRender/src/Rectangle.js","webpack://ScratchRender/src/RenderConstants.js","webpack://ScratchRender/src/RenderWebGL.js","webpack://ScratchRender/src/SVGSkin.js","webpack://ScratchRender/src/ShaderManager.js","webpack://ScratchRender/src/Silhouette.js","webpack://ScratchRender/src/Skin.js","webpack://ScratchRender/src/TextBubbleSkin.js","webpack://ScratchRender/src/index.js","webpack://ScratchRender/src/util/canvas-measurement-provider.js","webpack://ScratchRender/src/util/color-conversions.js","webpack://ScratchRender/src/util/log.js","webpack://ScratchRender/src/util/text-wrapper.js","webpack://ScratchRender/external \"events\"","webpack://ScratchRender/external \"hull.js\"","webpack://ScratchRender/external \"scratch-svg-renderer\"","webpack://ScratchRender/external \"stream\"","webpack://ScratchRender/external \"twgl.js\"","webpack://ScratchRender/external \"util\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","module.exports = require(\"grapheme-breaker\");","module.exports = require(\"linebreak\");","function M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n","// default filter\nvar Transform = require('./transform.js');\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n","var Transform = require('./transform.js'),\n    Filter = require('./filter.js');\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n","var microee = require('microee');\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n","module.exports = require('./common/minilog.js');\n\nvar consoleLogger = require('./node/console.js');\n\n// if we are running inside Electron then use the web version of console.js\nvar isElectron = (typeof window !== 'undefined' && window.process && window.process.type === 'renderer');\nif (isElectron) {\n  consoleLogger = require('./web/console.js').minilog;\n}\n\n// intercept the pipe method and transparently wrap the stringifier, if the\n// destination is a Node core stream\n\nmodule.exports.Stringifier = require('./node/stringify.js');\n\nvar oldPipe = module.exports.pipe;\nmodule.exports.pipe = function(dest) {\n  if(dest instanceof require('stream')) {\n    return oldPipe.call(module.exports, new (module.exports.Stringifier)).pipe(dest);\n  } else {\n    return oldPipe.call(module.exports, dest);\n  }\n};\n\nmodule.exports.defaultBackend = consoleLogger;\nmodule.exports.defaultFormatter = consoleLogger.formatMinilog;\n\nmodule.exports.backends = {\n  redis: require('./node/redis.js'),\n  nodeConsole: consoleLogger,\n  console: consoleLogger\n};\n","var Transform = require('../common/transform.js');\n\nfunction ConsoleBackend() { }\n\nTransform.mixin(ConsoleBackend);\n\nConsoleBackend.prototype.write = function() {\n  console.log.apply(console, arguments);\n};\n\nvar e = new ConsoleBackend();\n\nvar levelMap = require('./formatters/util.js').levelMap;\n\ne.filterEnv = function() {\n  console.error('Minilog.backends.console.filterEnv is deprecated in Minilog v2.');\n  // return the instance of Minilog\n  return require('../common/minilog.js');\n};\n\ne.formatters = [\n    'formatClean', 'formatColor', 'formatNpm',\n    'formatLearnboost', 'formatMinilog', 'formatWithStack', 'formatTime'\n];\n\ne.formatClean = new (require('./formatters/clean.js'));\ne.formatColor = new (require('./formatters/color.js'));\ne.formatNpm = new (require('./formatters/npm.js'));\ne.formatLearnboost = new (require('./formatters/learnboost.js'));\ne.formatMinilog = new (require('./formatters/minilog.js'));\ne.formatWithStack = new (require('./formatters/withstack.js'));\ne.formatTime = new (require('./formatters/time.js'));\n\nmodule.exports = e;\n","var Transform = require('../../common/transform.js');\n\nfunction FormatClean() {}\n\nTransform.mixin(FormatClean);\n\nFormatClean.prototype.write = function(name, level, args) {\n  function pad(s) { return (s.toString().length == 1? '0'+s : s); }\n  this.emit('item', (name ? name + ' ' : '') + (level ? level + ' ' : '') + args.join(' '));\n};\n\nmodule.exports = FormatClean;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatColor() {}\n\nTransform.mixin(FormatColor);\n\nFormatColor.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style('- ' + pad(level.toUpperCase()) + ' -', colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatColor;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatLearnboost() {}\n\nTransform.mixin(FormatLearnboost);\n\nFormatLearnboost.prototype.write = function(name, level, args) {\n  var colors = { debug: 'grey', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n          + (level ? style(level, colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatLearnboost;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style,\n    util = require('util');\n\nfunction FormatMinilog() {}\n\nTransform.mixin(FormatMinilog);\n\nFormatMinilog.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatMinilog;\n","var Transform = require('../../common/transform.js');\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var out = {\n        debug: '\\033[34;40m' + 'debug' + '\\033[39m ',\n        info: '\\033[32m' + 'info'  + '\\033[39m  ',\n        warn: '\\033[30;41m' + 'WARN' + '\\033[0m  ',\n        error: '\\033[31;40m' + 'ERR!' + '\\033[0m  '\n      };\n  this.emit('item', (name ? '\\033[37;40m'+ name +'\\033[0m ' : '')\n          + (level && out[level]? out[level] : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatNpm;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style,\n    util = require('util');\n\nfunction FormatTime() {}\n\nfunction timestamp() {\n  var d = new Date();\n  return ('0' + d.getDate()).slice(-2) + '-' +\n    ('0' + (d.getMonth() + 1)).slice(-2) + '-' +\n    d.getFullYear() + ' ' +\n    ('0' + d.getHours()).slice(-2) + ':' +\n    ('0' + d.getMinutes()).slice(-2) + ':' +\n    ('0' + d.getSeconds()).slice(-2) + '.' +\n    ('00' + d.getMilliseconds()).slice(-3);\n}\n\nTransform.mixin(FormatTime);\n\nFormatTime.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', style(timestamp() +' ', 'grey')\n            + (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatTime;\n","var styles = {\n    //styles\n    'bold'      : ['\\033[1m',  '\\033[22m'],\n    'italic'    : ['\\033[3m',  '\\033[23m'],\n    'underline' : ['\\033[4m',  '\\033[24m'],\n    'inverse'   : ['\\033[7m',  '\\033[27m'],\n    //grayscale\n    'white'     : ['\\033[37m', '\\033[39m'],\n    'grey'      : ['\\033[90m', '\\033[39m'],\n    'black'     : ['\\033[30m', '\\033[39m'],\n    //colors\n    'blue'      : ['\\033[34m', '\\033[39m'],\n    'cyan'      : ['\\033[36m', '\\033[39m'],\n    'green'     : ['\\033[32m', '\\033[39m'],\n    'magenta'   : ['\\033[35m', '\\033[39m'],\n    'red'       : ['\\033[31m', '\\033[39m'],\n    'yellow'    : ['\\033[33m', '\\033[39m']\n  };\n\nexports.levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nexports.style = function(str, style) {\n  return styles[style][0] + str + styles[style][1];\n}\n\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nfunction noop(a){\n  return a;\n}\n\nvar types = {\n  string: noop,\n  number: noop,\n  default: JSON.stringify.bind(JSON)\n};\n\nfunction stringify(args) {\n  return args.map(function(arg) {\n    return (types[typeof arg] || types.default)(arg);\n  });\n}\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  function getStack() {\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (err, stack) {\n      return stack;\n    };\n    var err = new Error;\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    return stack;\n  }\n\n  var frame = getStack()[5],\n      fileName = FormatNpm.fullPath ? frame.getFileName() : frame.getFileName().replace(/^.*\\/(.+)$/, '/$1');\n\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style(pad(level), colors[level]) + ' ' : '')\n          + style(fileName + \":\" + frame.getLineNumber(), 'grey')\n          + ' '\n          + stringify(args).join(' '));\n};\n\nFormatNpm.fullPath = true;\n\nmodule.exports = FormatNpm;\n\n","function RedisBackend(options) {\n  this.client = options.client;\n  this.key = options.key;\n}\n\nRedisBackend.prototype.write = function(str) {\n  this.client.rpush(this.key, str);\n};\n\nRedisBackend.prototype.end = function() {};\n\nRedisBackend.prototype.clear = function(cb) {\n  this.client.del(this.key, cb);\n};\n\nmodule.exports = RedisBackend;\n","var Transform = require('../common/transform.js');\n\nfunction Stringify() {}\n\nTransform.mixin(Stringify);\n\nStringify.prototype.write = function(name, level, args) {\n  var result = [];\n  if(name) result.push(name);\n  if(level) result.push(level);\n  result = result.concat(args);\n  for(var i = 0; i < result.length; i++) {\n    if(result[i] && typeof result[i] == 'object') {\n      // Buffers in Node.js look bad when stringified\n      if(result[i].constructor && result[i].constructor.isBuffer) {\n        result[i] = result[i].toString();\n      } else {\n        try {\n          result[i] = JSON.stringify(result[i]);\n        } catch(stringifyError) {\n          // happens when an object has a circular structure\n          // do not throw an error, when printing, the toString() method of the object will be used\n        }\n      }\n    } else {\n      result[i] = result[i];\n    }\n  }\n  this.emit('item',  result.join(' ') + '\\n');\n};\n\nmodule.exports = Stringify;\n","var Transform = require('../common/transform.js');\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = require('./formatters/color.js');\nlogger.minilog = require('./formatters/minilog.js');\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js');\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js'),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n","module.exports = \"precision mediump float;\\n\\n#ifdef DRAW_MODE_silhouette\\nuniform vec4 u_silhouetteColor;\\n#else // DRAW_MODE_silhouette\\n# ifdef ENABLE_color\\nuniform float u_color;\\n# endif // ENABLE_color\\n# ifdef ENABLE_brightness\\nuniform float u_brightness;\\n# endif // ENABLE_brightness\\n#endif // DRAW_MODE_silhouette\\n\\n#ifdef DRAW_MODE_colorMask\\nuniform vec3 u_colorMask;\\nuniform float u_colorMaskTolerance;\\n#endif // DRAW_MODE_colorMask\\n\\n#ifdef ENABLE_fisheye\\nuniform float u_fisheye;\\n#endif // ENABLE_fisheye\\n#ifdef ENABLE_whirl\\nuniform float u_whirl;\\n#endif // ENABLE_whirl\\n#ifdef ENABLE_pixelate\\nuniform float u_pixelate;\\nuniform vec2 u_skinSize;\\n#endif // ENABLE_pixelate\\n#ifdef ENABLE_mosaic\\nuniform float u_mosaic;\\n#endif // ENABLE_mosaic\\n#ifdef ENABLE_ghost\\nuniform float u_ghost;\\n#endif // ENABLE_ghost\\n\\n#ifdef DRAW_MODE_line\\nuniform vec4 u_lineColor;\\nuniform float u_lineThickness;\\nuniform float u_lineLength;\\n#endif // DRAW_MODE_line\\n\\n#ifdef DRAW_MODE_background\\nuniform vec4 u_backgroundColor;\\n#endif // DRAW_MODE_background\\n\\nuniform sampler2D u_skin;\\n\\n#ifndef DRAW_MODE_background\\nvarying vec2 v_texCoord;\\n#endif\\n\\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\\n// Smaller values can cause problems on some mobile devices.\\nconst float epsilon = 1e-3;\\n\\n#if !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n// Branchless color conversions based on code from:\\n// http://www.chilliant.com/rgb2hsv.html by Ian Taylor\\n// Based in part on work by Sam Hocevar and Emil Persson\\n// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation\\n\\n\\n// Convert an RGB color to Hue, Saturation, and Value.\\n// All components of input and output are expected to be in the [0,1] range.\\nvec3 convertRGB2HSV(vec3 rgb)\\n{\\n\\t// Hue calculation has 3 cases, depending on which RGB component is largest, and one of those cases involves a \\\"mod\\\"\\n\\t// operation. In order to avoid that \\\"mod\\\" we split the M==R case in two: one for G<B and one for B>G. The B>G case\\n\\t// will be calculated in the negative and fed through abs() in the hue calculation at the end.\\n\\t// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\\n\\tconst vec4 hueOffsets = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\n\\t// temp1.xy = sort B & G (largest first)\\n\\t// temp1.z = the hue offset we'll use if it turns out that R is the largest component (M==R)\\n\\t// temp1.w = the hue offset we'll use if it turns out that R is not the largest component (M==G or M==B)\\n\\tvec4 temp1 = rgb.b > rgb.g ? vec4(rgb.bg, hueOffsets.wz) : vec4(rgb.gb, hueOffsets.xy);\\n\\n\\t// temp2.x = the largest component of RGB (\\\"M\\\" / \\\"Max\\\")\\n\\t// temp2.yw = the smaller components of RGB, ordered for the hue calculation (not necessarily sorted by magnitude!)\\n\\t// temp2.z = the hue offset we'll use in the hue calculation\\n\\tvec4 temp2 = rgb.r > temp1.x ? vec4(rgb.r, temp1.yzx) : vec4(temp1.xyw, rgb.r);\\n\\n\\t// m = the smallest component of RGB (\\\"min\\\")\\n\\tfloat m = min(temp2.y, temp2.w);\\n\\n\\t// Chroma = M - m\\n\\tfloat C = temp2.x - m;\\n\\n\\t// Value = M\\n\\tfloat V = temp2.x;\\n\\n\\treturn vec3(\\n\\t\\tabs(temp2.z + (temp2.w - temp2.y) / (6.0 * C + epsilon)), // Hue\\n\\t\\tC / (temp2.x + epsilon), // Saturation\\n\\t\\tV); // Value\\n}\\n\\nvec3 convertHue2RGB(float hue)\\n{\\n\\tfloat r = abs(hue * 6.0 - 3.0) - 1.0;\\n\\tfloat g = 2.0 - abs(hue * 6.0 - 2.0);\\n\\tfloat b = 2.0 - abs(hue * 6.0 - 4.0);\\n\\treturn clamp(vec3(r, g, b), 0.0, 1.0);\\n}\\n\\nvec3 convertHSV2RGB(vec3 hsv)\\n{\\n\\tvec3 rgb = convertHue2RGB(hsv.x);\\n\\tfloat c = hsv.z * hsv.y;\\n\\treturn rgb * c + hsv.z - c;\\n}\\n#endif // !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\\n\\nconst vec2 kCenter = vec2(0.5, 0.5);\\n\\nvoid main()\\n{\\n\\t#if !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\\n\\tvec2 texcoord0 = v_texCoord;\\n\\n\\t#ifdef ENABLE_mosaic\\n\\ttexcoord0 = fract(u_mosaic * texcoord0);\\n\\t#endif // ENABLE_mosaic\\n\\n\\t#ifdef ENABLE_pixelate\\n\\t{\\n\\t\\t// TODO: clean up \\\"pixel\\\" edges\\n\\t\\tvec2 pixelTexelSize = u_skinSize / u_pixelate;\\n\\t\\ttexcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) / pixelTexelSize;\\n\\t}\\n\\t#endif // ENABLE_pixelate\\n\\n\\t#ifdef ENABLE_whirl\\n\\t{\\n\\t\\tconst float kRadius = 0.5;\\n\\t\\tvec2 offset = texcoord0 - kCenter;\\n\\t\\tfloat offsetMagnitude = length(offset);\\n\\t\\tfloat whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\\n\\t\\tfloat whirlActual = u_whirl * whirlFactor * whirlFactor;\\n\\t\\tfloat sinWhirl = sin(whirlActual);\\n\\t\\tfloat cosWhirl = cos(whirlActual);\\n\\t\\tmat2 rotationMatrix = mat2(\\n\\t\\t\\tcosWhirl, -sinWhirl,\\n\\t\\t\\tsinWhirl, cosWhirl\\n\\t\\t);\\n\\n\\t\\ttexcoord0 = rotationMatrix * offset + kCenter;\\n\\t}\\n\\t#endif // ENABLE_whirl\\n\\n\\t#ifdef ENABLE_fisheye\\n\\t{\\n\\t\\tvec2 vec = (texcoord0 - kCenter) / kCenter;\\n\\t\\tfloat vecLength = length(vec);\\n\\t\\tfloat r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\\n\\t\\tvec2 unit = vec / vecLength;\\n\\n\\t\\ttexcoord0 = kCenter + r * unit * kCenter;\\n\\t}\\n\\t#endif // ENABLE_fisheye\\n\\n\\tgl_FragColor = texture2D(u_skin, texcoord0);\\n\\n\\t#if defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\t// Divide premultiplied alpha values for proper color processing\\n\\t// Add epsilon to avoid dividing by 0 for fully transparent pixels\\n\\tgl_FragColor.rgb = clamp(gl_FragColor.rgb / (gl_FragColor.a + epsilon), 0.0, 1.0);\\n\\n\\t#ifdef ENABLE_color\\n\\t{\\n\\t\\tvec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\\n\\n\\t\\t// this code forces grayscale values to be slightly saturated\\n\\t\\t// so that some slight change of hue will be visible\\n\\t\\tconst float minLightness = 0.11 / 2.0;\\n\\t\\tconst float minSaturation = 0.09;\\n\\t\\tif (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\\n\\t\\telse if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\\n\\n\\t\\thsv.x = mod(hsv.x + u_color, 1.0);\\n\\t\\tif (hsv.x < 0.0) hsv.x += 1.0;\\n\\n\\t\\tgl_FragColor.rgb = convertHSV2RGB(hsv);\\n\\t}\\n\\t#endif // ENABLE_color\\n\\n\\t#ifdef ENABLE_brightness\\n\\tgl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\\n\\t#endif // ENABLE_brightness\\n\\n\\t// Re-multiply color values\\n\\tgl_FragColor.rgb *= gl_FragColor.a + epsilon;\\n\\n\\t#endif // defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\n\\t#ifdef ENABLE_ghost\\n\\tgl_FragColor *= u_ghost;\\n\\t#endif // ENABLE_ghost\\n\\n\\t#ifdef DRAW_MODE_silhouette\\n\\t// Discard fully transparent pixels for stencil test\\n\\tif (gl_FragColor.a == 0.0) {\\n\\t\\tdiscard;\\n\\t}\\n\\t// switch to u_silhouetteColor only AFTER the alpha test\\n\\tgl_FragColor = u_silhouetteColor;\\n\\t#else // DRAW_MODE_silhouette\\n\\n\\t#ifdef DRAW_MODE_colorMask\\n\\tvec3 maskDistance = abs(gl_FragColor.rgb - u_colorMask);\\n\\tvec3 colorMaskTolerance = vec3(u_colorMaskTolerance, u_colorMaskTolerance, u_colorMaskTolerance);\\n\\tif (any(greaterThan(maskDistance, colorMaskTolerance)))\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif // DRAW_MODE_colorMask\\n\\t#endif // DRAW_MODE_silhouette\\n\\n\\t#ifdef DRAW_MODE_straightAlpha\\n\\t// Un-premultiply alpha.\\n\\tgl_FragColor.rgb /= gl_FragColor.a + epsilon;\\n\\t#endif\\n\\n\\t#endif // !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\\n\\n\\t#ifdef DRAW_MODE_line\\n\\t// Maaaaagic antialiased-line-with-round-caps shader.\\n\\n\\t// \\\"along-the-lineness\\\". This increases parallel to the line.\\n\\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\\n\\t// past the end point.\\n\\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\\n\\n\\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\\n\\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\\n\\t// For the \\\"caps\\\", d will ramp down/up, giving us rounding.\\n\\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\\n\\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\\n\\t// Expand out the line by its thickness.\\n\\tline -= ((u_lineThickness - 1.0) * 0.5);\\n\\t// Because \\\"distance to the center of the line\\\" decreases the closer we get to the line, but we want more opacity\\n\\t// the closer we are to the line, invert it.\\n\\tgl_FragColor = u_lineColor * clamp(1.0 - line, 0.0, 1.0);\\n\\t#endif // DRAW_MODE_line\\n\\n\\t#ifdef DRAW_MODE_background\\n\\tgl_FragColor = u_backgroundColor;\\n\\t#endif\\n}\\n\"","module.exports = \"precision mediump float;\\n\\n#ifdef DRAW_MODE_line\\nuniform vec2 u_stageSize;\\nuniform float u_lineThickness;\\nuniform float u_lineLength;\\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\\n// point error when both points have large-ish coordinates.\\nuniform vec4 u_penPoints;\\n\\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\\n// Smaller values can cause problems on some mobile devices.\\nconst float epsilon = 1e-3;\\n#endif\\n\\n#if !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\\nuniform mat4 u_projectionMatrix;\\nuniform mat4 u_modelMatrix;\\nattribute vec2 a_texCoord;\\n#endif\\n\\nattribute vec2 a_position;\\n\\nvarying vec2 v_texCoord;\\n\\nvoid main() {\\n\\t#ifdef DRAW_MODE_line\\n\\t// Calculate a rotated (\\\"tight\\\") bounding box around the two pen points.\\n\\t// Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\\n\\t// it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\\n\\n\\t// Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\\n\\t// fall within the quad, even at a 45-degree diagonal\\n\\tvec2 position = a_position;\\n\\tfloat expandedRadius = (u_lineThickness * 0.5) + 1.4142135623730951;\\n\\n\\t// The X coordinate increases along the length of the line. It's 0 at the center of the origin point\\n\\t// and is in pixel-space (so at n pixels along the line, its value is n).\\n\\tv_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\\n\\t// The Y coordinate is perpendicular to the line. It's also in pixel-space.\\n\\tv_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\\n\\n\\tposition.x *= u_lineLength + (2.0 * expandedRadius);\\n\\tposition.y *= 2.0 * expandedRadius;\\n\\n\\t// 1. Center around first pen point\\n\\tposition -= expandedRadius;\\n\\n\\t// 2. Rotate quad to line angle\\n\\tvec2 pointDiff = u_penPoints.zw;\\n\\t// Ensure line has a nonzero length so it's rendered properly\\n\\t// As long as either component is nonzero, the line length will be nonzero\\n\\t// If the line is zero-length, give it a bit of horizontal length\\n\\tpointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\\n\\t// The `normalized` vector holds rotational values equivalent to sine/cosine\\n\\t// We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\\n\\t// pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\\n\\t// https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\\n\\tvec2 normalized = pointDiff / max(u_lineLength, epsilon);\\n\\tposition = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\\n\\n\\t// 3. Translate quad\\n\\tposition += u_penPoints.xy;\\n\\n\\t// 4. Apply view transform\\n\\tposition *= 2.0 / u_stageSize;\\n\\tgl_Position = vec4(position, 0, 1);\\n\\t#elif defined(DRAW_MODE_background)\\n\\tgl_Position = vec4(a_position * 2.0, 0, 1);\\n\\t#else\\n\\tgl_Position = u_projectionMatrix * u_modelMatrix * vec4(a_position, 0, 1);\\n\\tv_texCoord = a_texCoord;\\n\\t#endif\\n}\\n\"","const twgl = require('twgl.js');\n\nconst Skin = require('./Skin');\n\nclass BitmapSkin extends Skin {\n    /**\n     * Create a new Bitmap Skin.\n     * @extends Skin\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /** @type {!int} */\n        this._costumeResolution = 1;\n\n        /** @type {!RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {Array<int>} */\n        this._textureSize = [0, 0];\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        if (this._texture) {\n            this._renderer.gl.deleteTexture(this._texture);\n            this._texture = null;\n        }\n        super.dispose();\n    }\n\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin.\n     */\n    get size () {\n        return [this._textureSize[0] / this._costumeResolution, this._textureSize[1] / this._costumeResolution];\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        return this._texture || super.getTexture();\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {Array<number>} [rotationCenter] - Optional rotation center for the bitmap. If not supplied, it will be\n     * calculated from the bounding box\n     * @fires Skin.event:WasAltered\n     */\n    setBitmap (bitmapData, costumeResolution, rotationCenter) {\n        if (!bitmapData.width || !bitmapData.height) {\n            super.setEmptyImageData();\n            return;\n        }\n        const gl = this._renderer.gl;\n\n        // Preferably bitmapData is ImageData. ImageData speeds up updating\n        // Silhouette and is better handled by more browsers in regards to\n        // memory.\n        let textureData = bitmapData;\n        if (bitmapData instanceof HTMLCanvasElement) {\n            // Given a HTMLCanvasElement get the image data to pass to webgl and\n            // Silhouette.\n            const context = bitmapData.getContext('2d');\n            textureData = context.getImageData(0, 0, bitmapData.width, bitmapData.height);\n        }\n\n        if (this._texture === null) {\n            const textureOptions = {\n                auto: false,\n                wrap: gl.CLAMP_TO_EDGE\n            };\n\n            this._texture = twgl.createTexture(gl, textureOptions);\n        }\n\n        this._setTexture(textureData);\n\n        // Do these last in case any of the above throws an exception\n        this._costumeResolution = costumeResolution || 2;\n        this._textureSize = BitmapSkin._getBitmapSize(bitmapData);\n\n        if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();\n        this._rotationCenter[0] = rotationCenter[0];\n        this._rotationCenter[1] = rotationCenter[1];\n\n        this.emit(Skin.Events.WasAltered);\n    }\n\n    /**\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - bitmap data to inspect.\n     * @returns {Array<int>} the width and height of the bitmap data, in pixels.\n     * @private\n     */\n    static _getBitmapSize (bitmapData) {\n        if (bitmapData instanceof HTMLImageElement) {\n            return [bitmapData.naturalWidth || bitmapData.width, bitmapData.naturalHeight || bitmapData.height];\n        }\n\n        if (bitmapData instanceof HTMLVideoElement) {\n            return [bitmapData.videoWidth || bitmapData.width, bitmapData.videoHeight || bitmapData.height];\n        }\n\n        // ImageData or HTMLCanvasElement\n        return [bitmapData.width, bitmapData.height];\n    }\n\n}\n\nmodule.exports = BitmapSkin;\n","const twgl = require('twgl.js');\n\nconst Rectangle = require('./Rectangle');\nconst RenderConstants = require('./RenderConstants');\nconst ShaderManager = require('./ShaderManager');\nconst Skin = require('./Skin');\nconst EffectTransform = require('./EffectTransform');\nconst log = require('./util/log');\n\n/**\n * An internal workspace for calculating texture locations from world vectors\n * this is REUSED for memory conservation reasons\n * @type {twgl.v3}\n */\nconst __isTouchingPosition = twgl.v3.create();\nconst FLOATING_POINT_ERROR_ALLOWANCE = 1e-6;\n\n/**\n * Convert a scratch space location into a texture space float.  Uses the\n * internal __isTouchingPosition as a return value, so this should be copied\n * if you ever need to get two local positions and store both.  Requires that\n * the drawable inverseMatrix is up to date.\n *\n * @param {Drawable} drawable The drawable to get the inverse matrix and uniforms from\n * @param {twgl.v3} vec [x,y] scratch space vector\n * @return {twgl.v3} [x,y] texture space float vector - transformed by effects and matrix\n */\nconst getLocalPosition = (drawable, vec) => {\n    // Transfrom from world coordinates to Drawable coordinates.\n    const localPosition = __isTouchingPosition;\n    const v0 = vec[0];\n    const v1 = vec[1];\n    const m = drawable._inverseMatrix;\n    // var v2 = v[2];\n    const d = (v0 * m[3]) + (v1 * m[7]) + m[15];\n    // The RenderWebGL quad flips the texture's X axis. So rendered bottom\n    // left is 1, 0 and the top right is 0, 1. Flip the X axis so\n    // localPosition matches that transformation.\n    localPosition[0] = 0.5 - (((v0 * m[0]) + (v1 * m[4]) + m[12]) / d);\n    localPosition[1] = (((v0 * m[1]) + (v1 * m[5]) + m[13]) / d) + 0.5;\n    // Fix floating point issues near 0. Filed https://github.com/LLK/scratch-render/issues/688 that\n    // they're happening in the first place.\n    // TODO: Check if this can be removed after render pull 479 is merged\n    if (Math.abs(localPosition[0]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[0] = 0;\n    if (Math.abs(localPosition[1]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[1] = 0;\n    // Apply texture effect transform if the localPosition is within the drawable's space,\n    // and any effects are currently active.\n    if (drawable.enabledEffects !== 0 &&\n        (localPosition[0] >= 0 && localPosition[0] < 1) &&\n        (localPosition[1] >= 0 && localPosition[1] < 1)) {\n\n        EffectTransform.transformPoint(drawable, localPosition, localPosition);\n    }\n    return localPosition;\n};\n\nclass Drawable {\n    /**\n     * An object which can be drawn by the renderer.\n     * @todo double-buffer all rendering state (position, skin, effects, etc.)\n     * @param {!int} id - This Drawable's unique ID.\n     * @constructor\n     */\n    constructor (id) {\n        /** @type {!int} */\n        this._id = id;\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The model matrix, to concat with projection at draw time.\n             * @type {module:twgl/m4.Mat4}\n             */\n            u_modelMatrix: twgl.m4.identity(),\n\n            /**\n             * The color to use in the silhouette draw mode.\n             * @type {Array<number>}\n             */\n            u_silhouetteColor: Drawable.color4fFromID(this._id)\n        };\n\n        // Effect values are uniforms too\n        const numEffects = ShaderManager.EFFECTS.length;\n        for (let index = 0; index < numEffects; ++index) {\n            const effectName = ShaderManager.EFFECTS[index];\n            const effectInfo = ShaderManager.EFFECT_INFO[effectName];\n            const converter = effectInfo.converter;\n            this._uniforms[effectInfo.uniformName] = converter(0);\n        }\n\n        this._position = twgl.v3.create(0, 0);\n        this._scale = twgl.v3.create(100, 100);\n        this._direction = 90;\n        this._transformDirty = true;\n        this._rotationMatrix = twgl.m4.identity();\n        this._rotationTransformDirty = true;\n        this._rotationAdjusted = twgl.v3.create();\n        this._rotationCenterDirty = true;\n        this._skinScale = twgl.v3.create(0, 0, 0);\n        this._skinScaleDirty = true;\n        this._inverseMatrix = twgl.m4.identity();\n        this._inverseTransformDirty = true;\n        this._visible = true;\n\n        /** A bitmask identifying which effects are currently in use.\n         * @readonly\n         * @type {int} */\n        this.enabledEffects = 0;\n\n        /** @todo move convex hull functionality, maybe bounds functionality overall, to Skin classes */\n        this._convexHullPoints = null;\n        this._convexHullDirty = true;\n\n        // The precise bounding box will be from the transformed convex hull points,\n        // so initialize the array of transformed hull points in setConvexHullPoints.\n        // Initializing it once per convex hull recalculation avoids unnecessary creation of twgl.v3 objects.\n        this._transformedHullPoints = null;\n        this._transformedHullDirty = true;\n\n        this._skinWasAltered = this._skinWasAltered.bind(this);\n\n        this.isTouching = this._isTouchingNever;\n    }\n\n    /**\n     * Dispose of this Drawable. Do not use it after calling this method.\n     */\n    dispose () {\n        // Use the setter: disconnect events\n        this.skin = null;\n    }\n\n    /**\n     * Mark this Drawable's transform as dirty.\n     * It will be recalculated next time it's needed.\n     */\n    setTransformDirty () {\n        this._transformDirty = true;\n        this._inverseTransformDirty = true;\n        this._transformedHullDirty = true;\n    }\n\n    /**\n     * @returns {number} The ID for this Drawable.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {Skin} the current skin for this Drawable.\n     */\n    get skin () {\n        return this._skin;\n    }\n\n    /**\n     * @param {Skin} newSkin - A new Skin for this Drawable.\n     */\n    set skin (newSkin) {\n        if (this._skin !== newSkin) {\n            if (this._skin) {\n                this._skin.removeListener(Skin.Events.WasAltered, this._skinWasAltered);\n            }\n            this._skin = newSkin;\n            if (this._skin) {\n                this._skin.addListener(Skin.Events.WasAltered, this._skinWasAltered);\n            }\n            this._skinWasAltered();\n        }\n    }\n\n    /**\n     * @returns {Array<number>} the current scaling percentages applied to this Drawable. [100,100] is normal size.\n     */\n    get scale () {\n        return [this._scale[0], this._scale[1]];\n    }\n\n    /**\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering this Drawable.\n     */\n    getUniforms () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        return this._uniforms;\n    }\n\n    /**\n     * @returns {boolean} whether this Drawable is visible.\n     */\n    getVisible () {\n        return this._visible;\n    }\n\n    /**\n     * Update the position if it is different. Marks the transform as dirty.\n     * @param {Array.<number>} position A new position.\n     */\n    updatePosition (position) {\n        if (this._position[0] !== position[0] ||\n            this._position[1] !== position[1]) {\n            this._position[0] = Math.round(position[0]);\n            this._position[1] = Math.round(position[1]);\n            this.setTransformDirty();\n        }\n    }\n\n    /**\n     * Update the direction if it is different. Marks the transform as dirty.\n     * @param {number} direction A new direction.\n     */\n    updateDirection (direction) {\n        if (this._direction !== direction) {\n            this._direction = direction;\n            this._rotationTransformDirty = true;\n            this.setTransformDirty();\n        }\n    }\n\n    /**\n     * Update the scale if it is different. Marks the transform as dirty.\n     * @param {Array.<number>} scale A new scale.\n     */\n    updateScale (scale) {\n        if (this._scale[0] !== scale[0] ||\n            this._scale[1] !== scale[1]) {\n            this._scale[0] = scale[0];\n            this._scale[1] = scale[1];\n            this._rotationCenterDirty = true;\n            this._skinScaleDirty = true;\n            this.setTransformDirty();\n        }\n    }\n\n    /**\n     * Update visibility if it is different. Marks the convex hull as dirty.\n     * @param {boolean} visible A new visibility state.\n     */\n    updateVisible (visible) {\n        if (this._visible !== visible) {\n            this._visible = visible;\n            this.setConvexHullDirty();\n        }\n    }\n\n    /**\n     * Update an effect. Marks the convex hull as dirty if the effect changes shape.\n     * @param {string} effectName The name of the effect.\n     * @param {number} rawValue A new effect value.\n     */\n    updateEffect (effectName, rawValue) {\n        const effectInfo = ShaderManager.EFFECT_INFO[effectName];\n        if (rawValue) {\n            this.enabledEffects |= effectInfo.mask;\n        } else {\n            this.enabledEffects &= ~effectInfo.mask;\n        }\n        const converter = effectInfo.converter;\n        this._uniforms[effectInfo.uniformName] = converter(rawValue);\n        if (effectInfo.shapeChanges) {\n            this.setConvexHullDirty();\n        }\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @deprecated Use specific update* methods instead.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateProperties (properties) {\n        if ('position' in properties) {\n            this.updatePosition(properties.position);\n        }\n        if ('direction' in properties) {\n            this.updateDirection(properties.direction);\n        }\n        if ('scale' in properties) {\n            this.updateScale(properties.scale);\n        }\n        if ('visible' in properties) {\n            this.updateVisible(properties.visible);\n        }\n        const numEffects = ShaderManager.EFFECTS.length;\n        for (let index = 0; index < numEffects; ++index) {\n            const effectName = ShaderManager.EFFECTS[index];\n            if (effectName in properties) {\n                this.updateEffect(effectName, properties[effectName]);\n            }\n        }\n    }\n\n    /**\n     * Calculate the transform to use when rendering this Drawable.\n     * @private\n     */\n    _calculateTransform () {\n        if (this._rotationTransformDirty) {\n            const rotation = (270 - this._direction) * Math.PI / 180;\n\n            // Calling rotationZ sets the destination matrix to a rotation\n            // around the Z axis setting matrix components 0, 1, 4 and 5 with\n            // cosine and sine values of the rotation.\n            // twgl.m4.rotationZ(rotation, this._rotationMatrix);\n\n            // twgl assumes the last value set to the matrix was anything.\n            // Drawable knows, it was another rotationZ matrix, so we can skip\n            // assigning the values that will never change.\n            const c = Math.cos(rotation);\n            const s = Math.sin(rotation);\n            this._rotationMatrix[0] = c;\n            this._rotationMatrix[1] = s;\n            // this._rotationMatrix[2] = 0;\n            // this._rotationMatrix[3] = 0;\n            this._rotationMatrix[4] = -s;\n            this._rotationMatrix[5] = c;\n            // this._rotationMatrix[6] = 0;\n            // this._rotationMatrix[7] = 0;\n            // this._rotationMatrix[8] = 0;\n            // this._rotationMatrix[9] = 0;\n            // this._rotationMatrix[10] = 1;\n            // this._rotationMatrix[11] = 0;\n            // this._rotationMatrix[12] = 0;\n            // this._rotationMatrix[13] = 0;\n            // this._rotationMatrix[14] = 0;\n            // this._rotationMatrix[15] = 1;\n\n            this._rotationTransformDirty = false;\n        }\n\n        // Adjust rotation center relative to the skin.\n        if (this._rotationCenterDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // let rotationAdjusted = twgl.v3.subtract(\n            //     this.skin.rotationCenter,\n            //     twgl.v3.divScalar(this.skin.size, 2, this._rotationAdjusted),\n            //     this._rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.multiply(\n            //     rotationAdjusted, this._scale, rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.divScalar(\n            //     rotationAdjusted, 100, rotationAdjusted\n            // );\n            // rotationAdjusted[1] *= -1; // Y flipped to Scratch coordinate.\n            // rotationAdjusted[2] = 0; // Z coordinate is 0.\n\n            // Locally assign rotationCenter and skinSize to keep from having\n            // the Skin getter properties called twice while locally assigning\n            // their components for readability.\n            const rotationCenter = this.skin.rotationCenter;\n            const skinSize = this.skin.size;\n            const center0 = rotationCenter[0];\n            const center1 = rotationCenter[1];\n            const skinSize0 = skinSize[0];\n            const skinSize1 = skinSize[1];\n            const scale0 = this._scale[0];\n            const scale1 = this._scale[1];\n\n            const rotationAdjusted = this._rotationAdjusted;\n            rotationAdjusted[0] = (center0 - (skinSize0 / 2)) * scale0 / 100;\n            rotationAdjusted[1] = ((center1 - (skinSize1 / 2)) * scale1 / 100) * -1;\n            // rotationAdjusted[2] = 0;\n\n            this._rotationCenterDirty = false;\n        }\n\n        if (this._skinScaleDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // const scaledSize = twgl.v3.divScalar(\n            //     twgl.v3.multiply(this.skin.size, this._scale),\n            //     100\n            // );\n            // // was NaN because the vectors have only 2 components.\n            // scaledSize[2] = 0;\n\n            // Locally assign skinSize to keep from having the Skin getter\n            // properties called twice.\n            const skinSize = this.skin.size;\n            const scaledSize = this._skinScale;\n            scaledSize[0] = skinSize[0] * this._scale[0] / 100;\n            scaledSize[1] = skinSize[1] * this._scale[1] / 100;\n            // scaledSize[2] = 0;\n\n            this._skinScaleDirty = false;\n        }\n\n        const modelMatrix = this._uniforms.u_modelMatrix;\n\n        // twgl version of the following in function work.\n        // twgl.m4.identity(modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._position, modelMatrix);\n        // twgl.m4.multiply(modelMatrix, this._rotationMatrix, modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._rotationAdjusted, modelMatrix);\n        // twgl.m4.scale(modelMatrix, scaledSize, modelMatrix);\n\n        // Drawable configures a 3D matrix for drawing in WebGL, but most values\n        // will never be set because the inputs are on the X and Y position axis\n        // and the Z rotation axis. Drawable can bring the work inside\n        // _calculateTransform and greatly reduce the ammount of math and array\n        // assignments needed.\n\n        const scale0 = this._skinScale[0];\n        const scale1 = this._skinScale[1];\n        const rotation00 = this._rotationMatrix[0];\n        const rotation01 = this._rotationMatrix[1];\n        const rotation10 = this._rotationMatrix[4];\n        const rotation11 = this._rotationMatrix[5];\n        const adjusted0 = this._rotationAdjusted[0];\n        const adjusted1 = this._rotationAdjusted[1];\n        const position0 = this._position[0];\n        const position1 = this._position[1];\n\n        // Commented assignments show what the values are when the matrix was\n        // instantiated. Those values will never change so they do not need to\n        // be reassigned.\n        modelMatrix[0] = scale0 * rotation00;\n        modelMatrix[1] = scale0 * rotation01;\n        // modelMatrix[2] = 0;\n        // modelMatrix[3] = 0;\n        modelMatrix[4] = scale1 * rotation10;\n        modelMatrix[5] = scale1 * rotation11;\n        // modelMatrix[6] = 0;\n        // modelMatrix[7] = 0;\n        // modelMatrix[8] = 0;\n        // modelMatrix[9] = 0;\n        // modelMatrix[10] = 1;\n        // modelMatrix[11] = 0;\n        modelMatrix[12] = (rotation00 * adjusted0) + (rotation10 * adjusted1) + position0;\n        modelMatrix[13] = (rotation01 * adjusted0) + (rotation11 * adjusted1) + position1;\n        // modelMatrix[14] = 0;\n        // modelMatrix[15] = 1;\n\n        this._transformDirty = false;\n    }\n\n    /**\n     * Whether the Drawable needs convex hull points provided by the renderer.\n     * @return {boolean} True when no convex hull known, or it's dirty.\n     */\n    needsConvexHullPoints () {\n        return !this._convexHullPoints || this._convexHullDirty || this._convexHullPoints.length === 0;\n    }\n\n    /**\n     * Set the convex hull to be dirty.\n     * Do this whenever the Drawable's shape has possibly changed.\n     */\n    setConvexHullDirty () {\n        this._convexHullDirty = true;\n    }\n\n    /**\n     * Set the convex hull points for the Drawable.\n     * @param {Array<Array<number>>} points Convex hull points, as [[x, y], ...]\n     */\n    setConvexHullPoints (points) {\n        this._convexHullPoints = points;\n        this._convexHullDirty = false;\n\n        // Re-create the \"transformed hull points\" array.\n        // We only do this when the hull points change to avoid unnecessary allocations and GC.\n        this._transformedHullPoints = [];\n        for (let i = 0; i < points.length; i++) {\n            this._transformedHullPoints.push(twgl.v3.create());\n        }\n        this._transformedHullDirty = true;\n    }\n\n    /**\n     * @function\n     * @name isTouching\n     * Check if the world position touches the skin.\n     * The caller is responsible for ensuring this drawable's inverse matrix & its skin's silhouette are up-to-date.\n     * @see updateCPURenderAttributes\n     * @param {twgl.v3} vec World coordinate vector.\n     * @return {boolean} True if the world position touches the skin.\n     */\n\n    // `updateCPURenderAttributes` sets this Drawable instance's `isTouching` method\n    // to one of the following three functions:\n    // If this drawable has no skin, set it to `_isTouchingNever`.\n    // Otherwise, if this drawable uses nearest-neighbor scaling at its current scale, set it to `_isTouchingNearest`.\n    // Otherwise, set it to `_isTouchingLinear`.\n    // This allows several checks to be moved from the `isTouching` function to `updateCPURenderAttributes`.\n\n    // eslint-disable-next-line no-unused-vars\n    _isTouchingNever (vec) {\n        return false;\n    }\n\n    _isTouchingNearest (vec) {\n        return this.skin.isTouchingNearest(getLocalPosition(this, vec));\n    }\n\n    _isTouchingLinear (vec) {\n        return this.skin.isTouchingLinear(getLocalPosition(this, vec));\n    }\n\n    /**\n     * Get the precise bounds for a Drawable.\n     * This function applies the transform matrix to the known convex hull,\n     * and then finds the minimum box along the axes.\n     * Before calling this, ensure the renderer has updated convex hull points.\n     * @param {?Rectangle} result optional destination for bounds calculation\n     * @return {!Rectangle} Bounds for a tight box around the Drawable.\n     */\n    getBounds (result) {\n        if (this.needsConvexHullPoints()) {\n            throw new Error('Needs updated convex hull points before bounds calculation.');\n        }\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const transformedHullPoints = this._getTransformedHullPoints();\n        // Search through transformed points to generate box on axes.\n        result = result || new Rectangle();\n        result.initFromPointsAABB(transformedHullPoints);\n        return result;\n    }\n\n    /**\n     * Get the precise bounds for the upper 8px slice of the Drawable.\n     * Used for calculating where to position a text bubble.\n     * Before calling this, ensure the renderer has updated convex hull points.\n     * @param {?Rectangle} result optional destination for bounds calculation\n     * @return {!Rectangle} Bounds for a tight box around a slice of the Drawable.\n     */\n    getBoundsForBubble (result) {\n        if (this.needsConvexHullPoints()) {\n            throw new Error('Needs updated convex hull points before bubble bounds calculation.');\n        }\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const slice = 8; // px, how tall the top slice to measure should be.\n        const transformedHullPoints = this._getTransformedHullPoints();\n        const maxY = Math.max.apply(null, transformedHullPoints.map(p => p[1]));\n        const filteredHullPoints = transformedHullPoints.filter(p => p[1] > maxY - slice);\n        // Search through filtered points to generate box on axes.\n        result = result || new Rectangle();\n        result.initFromPointsAABB(filteredHullPoints);\n        return result;\n    }\n\n    /**\n     * Get the rough axis-aligned bounding box for the Drawable.\n     * Calculated by transforming the skin's bounds.\n     * Note that this is less precise than the box returned by `getBounds`,\n     * which is tightly snapped to account for a Drawable's transparent regions.\n     * `getAABB` returns a much less accurate bounding box, but will be much\n     * faster to calculate so may be desired for quick checks/optimizations.\n     * @param {?Rectangle} result optional destination for bounds calculation\n     * @return {!Rectangle} Rough axis-aligned bounding box for Drawable.\n     */\n    getAABB (result) {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const tm = this._uniforms.u_modelMatrix;\n        result = result || new Rectangle();\n        result.initFromModelMatrix(tm);\n        return result;\n    }\n\n    /**\n     * Return the best Drawable bounds possible without performing graphics queries.\n     * I.e., returns the tight bounding box when the convex hull points are already\n     * known, but otherwise return the rough AABB of the Drawable.\n     * @param {?Rectangle} result optional destination for bounds calculation\n     * @return {!Rectangle} Bounds for the Drawable.\n     */\n    getFastBounds (result) {\n        if (!this.needsConvexHullPoints()) {\n            return this.getBounds(result);\n        }\n        return this.getAABB(result);\n    }\n\n    /**\n     * Transform all the convex hull points by the current Drawable's\n     * transform. This allows us to skip recalculating the convex hull\n     * for many Drawable updates, including translation, rotation, scaling.\n     * @return {!Array.<!Array.number>} Array of glPoints which are Array<x, y>\n     * @private\n     */\n    _getTransformedHullPoints () {\n        if (!this._transformedHullDirty) {\n            return this._transformedHullPoints;\n        }\n\n        const projection = twgl.m4.ortho(-1, 1, -1, 1, -1, 1);\n        const skinSize = this.skin.size;\n        const halfXPixel = 1 / skinSize[0] / 2;\n        const halfYPixel = 1 / skinSize[1] / 2;\n        const tm = twgl.m4.multiply(this._uniforms.u_modelMatrix, projection);\n        for (let i = 0; i < this._convexHullPoints.length; i++) {\n            const point = this._convexHullPoints[i];\n            const dstPoint = this._transformedHullPoints[i];\n\n            dstPoint[0] = 0.5 + (-point[0] / skinSize[0]) - halfXPixel;\n            dstPoint[1] = (point[1] / skinSize[1]) - 0.5 + halfYPixel;\n            twgl.m4.transformPoint(tm, dstPoint, dstPoint);\n        }\n\n        this._transformedHullDirty = false;\n\n        return this._transformedHullPoints;\n    }\n\n    /**\n     * Update the transform matrix and calculate it's inverse for collision\n     * and local texture position purposes.\n     */\n    updateMatrix () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        // Get the inverse of the model matrix or update it.\n        if (this._inverseTransformDirty) {\n            const inverse = this._inverseMatrix;\n            twgl.m4.copy(this._uniforms.u_modelMatrix, inverse);\n            // The normal matrix uses a z scaling of 0 causing model[10] to be\n            // 0. Getting a 4x4 inverse is impossible without a scaling in x, y,\n            // and z.\n            inverse[10] = 1;\n            twgl.m4.inverse(inverse, inverse);\n            this._inverseTransformDirty = false;\n        }\n    }\n\n    /**\n     * Update everything necessary to render this drawable on the CPU.\n     */\n    updateCPURenderAttributes () {\n        this.updateMatrix();\n        // CPU rendering always occurs at the \"native\" size, so no need to scale up this._scale\n        if (this.skin) {\n            this.skin.updateSilhouette(this._scale);\n\n            if (this.skin.useNearest(this._scale, this)) {\n                this.isTouching = this._isTouchingNearest;\n            } else {\n                this.isTouching = this._isTouchingLinear;\n            }\n        } else {\n            log.warn(`Could not find skin for drawable with id: ${this._id}`);\n\n            this.isTouching = this._isTouchingNever;\n        }\n    }\n\n    /**\n     * Respond to an internal change in the current Skin.\n     * @private\n     */\n    _skinWasAltered () {\n        this._rotationCenterDirty = true;\n        this._skinScaleDirty = true;\n        this.setConvexHullDirty();\n        this.setTransformDirty();\n    }\n\n    /**\n     * Calculate a color to represent the given ID number. At least one component of\n     * the resulting color will be non-zero if the ID is not RenderConstants.ID_NONE.\n     * @param {int} id The ID to convert.\n     * @returns {Array<number>} An array of [r,g,b,a], each component in the range [0,1].\n     */\n    static color4fFromID (id) {\n        id -= RenderConstants.ID_NONE;\n        const r = ((id >> 0) & 255) / 255.0;\n        const g = ((id >> 8) & 255) / 255.0;\n        const b = ((id >> 16) & 255) / 255.0;\n        return [r, g, b, 1.0];\n    }\n\n    /**\n     * Calculate the ID number represented by the given color. If all components of\n     * the color are zero, the result will be RenderConstants.ID_NONE; otherwise the result\n     * will be a valid ID.\n     * @param {int} r The red value of the color, in the range [0,255].\n     * @param {int} g The green value of the color, in the range [0,255].\n     * @param {int} b The blue value of the color, in the range [0,255].\n     * @returns {int} The ID represented by that color.\n     */\n    static color3bToID (r, g, b) {\n        let id;\n        id = (r & 255) << 0;\n        id |= (g & 255) << 8;\n        id |= (b & 255) << 16;\n        return id + RenderConstants.ID_NONE;\n    }\n\n    /**\n     * Sample a color from a drawable's texture.\n     * The caller is responsible for ensuring this drawable's inverse matrix & its skin's silhouette are up-to-date.\n     * @see updateCPURenderAttributes\n     * @param {twgl.v3} vec The scratch space [x,y] vector\n     * @param {Drawable} drawable The drawable to sample the texture from\n     * @param {Uint8ClampedArray} dst The \"color4b\" representation of the texture at point.\n     * @param {number} [effectMask] A bitmask for which effects to use. Optional.\n     * @returns {Uint8ClampedArray} The dst object filled with the color4b\n     */\n    static sampleColor4b (vec, drawable, dst, effectMask) {\n        const localPosition = getLocalPosition(drawable, vec);\n        if (localPosition[0] < 0 || localPosition[1] < 0 ||\n            localPosition[0] > 1 || localPosition[1] > 1) {\n            dst[0] = 0;\n            dst[1] = 0;\n            dst[2] = 0;\n            dst[3] = 0;\n            return dst;\n        }\n\n        const textColor =\n        // commenting out to only use nearest for now\n        // drawable.skin.useNearest(drawable._scale, drawable) ?\n             drawable.skin._silhouette.colorAtNearest(localPosition, dst);\n        // : drawable.skin._silhouette.colorAtLinear(localPosition, dst);\n\n        if (drawable.enabledEffects === 0) return textColor;\n        return EffectTransform.transformColor(drawable, textColor, effectMask);\n    }\n}\n\nmodule.exports = Drawable;\n","/**\n * @fileoverview\n * A utility to transform a texture coordinate to another texture coordinate\n * representing how the shaders apply effects.\n */\n\nconst twgl = require('twgl.js');\n\nconst {rgbToHsv, hsvToRgb} = require('./util/color-conversions');\nconst ShaderManager = require('./ShaderManager');\n\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nconst CENTER_X = 0.5;\n\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nconst CENTER_Y = 0.5;\n\n/**\n * Reused memory location for storing an HSV color value.\n * @type {Array<number>}\n */\nconst __hsv = [0, 0, 0];\n\nclass EffectTransform {\n\n    /**\n     * Transform a color in-place given the drawable's effect uniforms.  Will apply\n     * Ghost and Color and Brightness effects.\n     * @param {Drawable} drawable The drawable to get uniforms from.\n     * @param {Uint8ClampedArray} inOutColor The color to transform.\n     * @param {number} [effectMask] A bitmask for which effects to use. Optional.\n     * @returns {Uint8ClampedArray} dst filled with the transformed color\n     */\n    static transformColor (drawable, inOutColor, effectMask) {\n        // If the color is fully transparent, don't bother attempting any transformations.\n        if (inOutColor[3] === 0) {\n            return inOutColor;\n        }\n\n        let effects = drawable.enabledEffects;\n        if (typeof effectMask === 'number') effects &= effectMask;\n        const uniforms = drawable.getUniforms();\n\n        const enableColor = (effects & ShaderManager.EFFECT_INFO.color.mask) !== 0;\n        const enableBrightness = (effects & ShaderManager.EFFECT_INFO.brightness.mask) !== 0;\n\n        if (enableColor || enableBrightness) {\n            // gl_FragColor.rgb /= gl_FragColor.a + epsilon;\n            // Here, we're dividing by the (previously pre-multiplied) alpha to ensure HSV is properly calculated\n            // for partially transparent pixels.\n            // epsilon is present in the shader because dividing by 0 (fully transparent pixels) messes up calculations.\n            // We're doing this with a Uint8ClampedArray here, so dividing by 0 just gives 255. We're later multiplying\n            // by 0 again, so it won't affect results.\n            const alpha = inOutColor[3] / 255;\n            inOutColor[0] /= alpha;\n            inOutColor[1] /= alpha;\n            inOutColor[2] /= alpha;\n\n            if (enableColor) {\n                // vec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\n                const hsv = rgbToHsv(inOutColor, __hsv);\n\n                // this code forces grayscale values to be slightly saturated\n                // so that some slight change of hue will be visible\n                // const float minLightness = 0.11 / 2.0;\n                const minV = 0.11 / 2.0;\n                // const float minSaturation = 0.09;\n                const minS = 0.09;\n                // if (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\n                if (hsv[2] < minV) {\n                    hsv[0] = 0;\n                    hsv[1] = 1;\n                    hsv[2] = minV;\n                // else if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\n                } else if (hsv[1] < minS) {\n                    hsv[0] = 0;\n                    hsv[1] = minS;\n                }\n\n                // hsv.x = mod(hsv.x + u_color, 1.0);\n                // if (hsv.x < 0.0) hsv.x += 1.0;\n                hsv[0] = (uniforms.u_color + hsv[0] + 1);\n\n                // gl_FragColor.rgb = convertHSV2RGB(hsl);\n                hsvToRgb(hsv, inOutColor);\n            }\n\n            if (enableBrightness) {\n                const brightness = uniforms.u_brightness * 255;\n                // gl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\n                // We don't need to clamp because the Uint8ClampedArray does that for us\n                inOutColor[0] += brightness;\n                inOutColor[1] += brightness;\n                inOutColor[2] += brightness;\n            }\n\n            // gl_FragColor.rgb *= gl_FragColor.a + epsilon;\n            // Now we're doing the reverse, premultiplying by the alpha once again.\n            inOutColor[0] *= alpha;\n            inOutColor[1] *= alpha;\n            inOutColor[2] *= alpha;\n        }\n\n        if ((effects & ShaderManager.EFFECT_INFO.ghost.mask) !== 0) {\n            // gl_FragColor *= u_ghost\n            inOutColor[0] *= uniforms.u_ghost;\n            inOutColor[1] *= uniforms.u_ghost;\n            inOutColor[2] *= uniforms.u_ghost;\n            inOutColor[3] *= uniforms.u_ghost;\n        }\n\n        return inOutColor;\n    }\n\n    /**\n     * Transform a texture coordinate to one that would be select after applying shader effects.\n     * @param {Drawable} drawable The drawable whose effects to emulate.\n     * @param {twgl.v3} vec The texture coordinate to transform.\n     * @param {twgl.v3} dst A place to store the output coordinate.\n     * @return {twgl.v3} dst - The coordinate after being transform by effects.\n     */\n    static transformPoint (drawable, vec, dst) {\n        twgl.v3.copy(vec, dst);\n\n        const effects = drawable.enabledEffects;\n        const uniforms = drawable.getUniforms();\n        if ((effects & ShaderManager.EFFECT_INFO.mosaic.mask) !== 0) {\n            // texcoord0 = fract(u_mosaic * texcoord0);\n            dst[0] = uniforms.u_mosaic * dst[0] % 1;\n            dst[1] = uniforms.u_mosaic * dst[1] % 1;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.pixelate.mask) !== 0) {\n            const skinUniforms = drawable.skin.getUniforms();\n            // vec2 pixelTexelSize = u_skinSize / u_pixelate;\n            const texelX = skinUniforms.u_skinSize[0] / uniforms.u_pixelate;\n            const texelY = skinUniforms.u_skinSize[1] / uniforms.u_pixelate;\n            // texcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) /\n            //   pixelTexelSize;\n            dst[0] = (Math.floor(dst[0] * texelX) + CENTER_X) / texelX;\n            dst[1] = (Math.floor(dst[1] * texelY) + CENTER_Y) / texelY;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.whirl.mask) !== 0) {\n            // const float kRadius = 0.5;\n            const RADIUS = 0.5;\n            // vec2 offset = texcoord0 - kCenter;\n            const offsetX = dst[0] - CENTER_X;\n            const offsetY = dst[1] - CENTER_Y;\n            // float offsetMagnitude = length(offset);\n            const offsetMagnitude = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));\n            // float whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\n            const whirlFactor = Math.max(1.0 - (offsetMagnitude / RADIUS), 0.0);\n            // float whirlActual = u_whirl * whirlFactor * whirlFactor;\n            const whirlActual = uniforms.u_whirl * whirlFactor * whirlFactor;\n            // float sinWhirl = sin(whirlActual);\n            const sinWhirl = Math.sin(whirlActual);\n            // float cosWhirl = cos(whirlActual);\n            const cosWhirl = Math.cos(whirlActual);\n            // mat2 rotationMatrix = mat2(\n            //     cosWhirl, -sinWhirl,\n            //     sinWhirl, cosWhirl\n            // );\n            const rot1 = cosWhirl;\n            const rot2 = -sinWhirl;\n            const rot3 = sinWhirl;\n            const rot4 = cosWhirl;\n\n            // texcoord0 = rotationMatrix * offset + kCenter;\n            dst[0] = (rot1 * offsetX) + (rot3 * offsetY) + CENTER_X;\n            dst[1] = (rot2 * offsetX) + (rot4 * offsetY) + CENTER_Y;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.fisheye.mask) !== 0) {\n            // vec2 vec = (texcoord0 - kCenter) / kCenter;\n            const vX = (dst[0] - CENTER_X) / CENTER_X;\n            const vY = (dst[1] - CENTER_Y) / CENTER_Y;\n            // float vecLength = length(vec);\n            const vLength = Math.sqrt((vX * vX) + (vY * vY));\n            // float r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\n            const r = Math.pow(Math.min(vLength, 1), uniforms.u_fisheye) * Math.max(1, vLength);\n            // vec2 unit = vec / vecLength;\n            const unitX = vX / vLength;\n            const unitY = vY / vLength;\n            // texcoord0 = kCenter + r * unit * kCenter;\n            dst[0] = CENTER_X + (r * unitX * CENTER_X);\n            dst[1] = CENTER_Y + (r * unitY * CENTER_Y);\n        }\n\n        return dst;\n    }\n}\n\nmodule.exports = EffectTransform;\n","const twgl = require('twgl.js');\n\nconst RenderConstants = require('./RenderConstants');\nconst Skin = require('./Skin');\n\nconst ShaderManager = require('./ShaderManager');\n\n/**\n * Attributes to use when drawing with the pen\n * @typedef {object} PenSkin#PenAttributes\n * @property {number} [diameter] - The size (diameter) of the pen.\n * @property {Array<number>} [color4f] - The pen color as an array of [r,g,b,a], each component in the range [0,1].\n */\n\n/**\n * The pen attributes to use when unspecified.\n * @type {PenSkin#PenAttributes}\n * @memberof PenSkin\n * @private\n * @const\n */\nconst DefaultPenAttributes = {\n    color4f: [0, 0, 1, 1],\n    diameter: 1\n};\n\n/**\n * Reused memory location for storing a premultiplied pen color.\n * @type {FloatArray}\n */\nconst __premultipliedColor = [0, 0, 0, 0];\n\nclass PenSkin extends Skin {\n    /**\n     * Create a Skin which implements a Scratch pen layer.\n     * @param {int} id - The unique ID for this Skin.\n     * @param {RenderWebGL} renderer - The renderer which will use this Skin.\n     * @extends Skin\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /**\n         * @private\n         * @type {RenderWebGL}\n         */\n        this._renderer = renderer;\n\n        /** @type {Array<number>} */\n        this._size = null;\n\n        /** @type {WebGLFramebuffer} */\n        this._framebuffer = null;\n\n        /** @type {boolean} */\n        this._silhouetteDirty = false;\n\n        /** @type {Uint8Array} */\n        this._silhouettePixels = null;\n\n        /** @type {ImageData} */\n        this._silhouetteImageData = null;\n\n        /** @type {object} */\n        this._lineOnBufferDrawRegionId = {\n            enter: () => this._enterDrawLineOnBuffer(),\n            exit: () => this._exitDrawLineOnBuffer()\n        };\n\n        /** @type {object} */\n        this._usePenBufferDrawRegionId = {\n            enter: () => this._enterUsePenBuffer(),\n            exit: () => this._exitUsePenBuffer()\n        };\n\n        /** @type {twgl.BufferInfo} */\n        this._lineBufferInfo = twgl.createBufferInfoFromArrays(this._renderer.gl, {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    1, 0,\n                    0, 0,\n                    1, 1,\n                    1, 1,\n                    0, 0,\n                    0, 1\n                ]\n            }\n        });\n\n        const NO_EFFECTS = 0;\n        /** @type {twgl.ProgramInfo} */\n        this._lineShader = this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.line, NO_EFFECTS);\n\n        this.onNativeSizeChanged = this.onNativeSizeChanged.bind(this);\n        this._renderer.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this._setCanvasSize(renderer.getNativeSize());\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        this._renderer.removeListener(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n        this._renderer.gl.deleteTexture(this._texture);\n        this._texture = null;\n        super.dispose();\n    }\n\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin. [width, height]\n     */\n    get size () {\n        return this._size;\n    }\n\n    useNearest (scale) {\n        // Use nearest-neighbor interpolation when scaling up the pen skin-- this matches Scratch 2.0.\n        // When scaling it down, use linear interpolation to avoid giving pen lines a \"dashed\" appearance.\n        return Math.max(scale[0], scale[1]) >= 100;\n    }\n\n    /**\n     * @param {Array<number>} scale The X and Y scaling factors to be used, as percentages of this skin's \"native\" size.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        return this._texture;\n    }\n\n    /**\n     * Clear the pen layer.\n     */\n    clear () {\n        this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);\n\n        /* Reset framebuffer to transparent black */\n        const gl = this._renderer.gl;\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Draw a point on the pen layer.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n    drawPoint (penAttributes, x, y) {\n        this.drawLine(penAttributes, x, y, x, y);\n    }\n\n    /**\n     * Draw a line on the pen layer.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    drawLine (penAttributes, x0, y0, x1, y1) {\n        // For compatibility with Scratch 2.0, offset pen lines of width 1 and 3 so they're pixel-aligned.\n        // See https://github.com/LLK/scratch-render/pull/314\n        const diameter = penAttributes.diameter || DefaultPenAttributes.diameter;\n        const offset = (diameter === 1 || diameter === 3) ? 0.5 : 0;\n\n        this._drawLineOnBuffer(\n            penAttributes,\n            x0 + offset, y0 + offset,\n            x1 + offset, y1 + offset\n        );\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Prepare to draw lines in the _lineOnBufferDrawRegionId region.\n     */\n    _enterDrawLineOnBuffer () {\n        const gl = this._renderer.gl;\n\n        twgl.bindFramebufferInfo(gl, this._framebuffer);\n\n        gl.viewport(0, 0, this._size[0], this._size[1]);\n\n        const currentShader = this._lineShader;\n        gl.useProgram(currentShader.program);\n        twgl.setBuffersAndAttributes(gl, currentShader, this._lineBufferInfo);\n\n        const uniforms = {\n            u_skin: this._texture,\n            u_stageSize: this._size\n        };\n\n        twgl.setUniforms(currentShader, uniforms);\n    }\n\n    /**\n     * Return to a base state from _lineOnBufferDrawRegionId.\n     */\n    _exitDrawLineOnBuffer () {\n        const gl = this._renderer.gl;\n\n        twgl.bindFramebufferInfo(gl, null);\n    }\n\n    /**\n     * Prepare to do things with this PenSkin's framebuffer\n     */\n    _enterUsePenBuffer () {\n        twgl.bindFramebufferInfo(this._renderer.gl, this._framebuffer);\n    }\n\n    /**\n     * Return to a base state\n     */\n    _exitUsePenBuffer () {\n        twgl.bindFramebufferInfo(this._renderer.gl, null);\n    }\n\n    /**\n     * Draw a line on the framebuffer.\n     * Note that the point coordinates are in the following coordinate space:\n     * +y is down, (0, 0) is the center, and the coords range from (-width / 2, -height / 2) to (height / 2, width / 2).\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    _drawLineOnBuffer (penAttributes, x0, y0, x1, y1) {\n        const gl = this._renderer.gl;\n\n        const currentShader = this._lineShader;\n\n        this._renderer.enterDrawRegion(this._lineOnBufferDrawRegionId);\n\n        // Premultiply pen color by pen transparency\n        const penColor = penAttributes.color4f || DefaultPenAttributes.color4f;\n        __premultipliedColor[0] = penColor[0] * penColor[3];\n        __premultipliedColor[1] = penColor[1] * penColor[3];\n        __premultipliedColor[2] = penColor[2] * penColor[3];\n        __premultipliedColor[3] = penColor[3];\n\n        // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\n        // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n        // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\n        // Even GLSL's `length` function won't save us here:\n        // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n        const lineDiffX = x1 - x0;\n        const lineDiffY = y1 - y0;\n        const lineLength = Math.sqrt((lineDiffX * lineDiffX) + (lineDiffY * lineDiffY));\n\n        const uniforms = {\n            u_lineColor: __premultipliedColor,\n            u_lineThickness: penAttributes.diameter || DefaultPenAttributes.diameter,\n            u_lineLength: lineLength,\n            u_penPoints: [x0, -y0, lineDiffX, -lineDiffY]\n        };\n\n        twgl.setUniforms(currentShader, uniforms);\n\n        twgl.drawBufferInfo(gl, this._lineBufferInfo, gl.TRIANGLES);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * React to a change in the renderer's native size.\n     * @param {object} event - The change event.\n     */\n    onNativeSizeChanged (event) {\n        this._setCanvasSize(event.newSize);\n    }\n\n    /**\n     * Set the size of the pen canvas.\n     * @param {Array<int>} canvasSize - the new width and height for the canvas.\n     * @private\n     */\n    _setCanvasSize (canvasSize) {\n        const [width, height] = canvasSize;\n\n        this._size = canvasSize;\n        this._rotationCenter[0] = width / 2;\n        this._rotationCenter[1] = height / 2;\n\n        const gl = this._renderer.gl;\n\n        this._texture = twgl.createTexture(\n            gl,\n            {\n                mag: gl.NEAREST,\n                min: gl.NEAREST,\n                wrap: gl.CLAMP_TO_EDGE,\n                width,\n                height\n            }\n        );\n\n        const attachments = [\n            {\n                format: gl.RGBA,\n                attachment: this._texture\n            }\n        ];\n        if (this._framebuffer) {\n            twgl.resizeFramebufferInfo(gl, this._framebuffer, attachments, width, height);\n        } else {\n            this._framebuffer = twgl.createFramebufferInfo(gl, attachments, width, height);\n        }\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._silhouettePixels = new Uint8Array(Math.floor(width * height * 4));\n        this._silhouetteImageData = new ImageData(width, height);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * If there have been pen operations that have dirtied the canvas, update\n     * now before someone wants to use our silhouette.\n     */\n    updateSilhouette () {\n        if (this._silhouetteDirty) {\n            this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);\n            // Sample the framebuffer's pixels into the silhouette instance\n            const gl = this._renderer.gl;\n            gl.readPixels(\n                0, 0,\n                this._size[0], this._size[1],\n                gl.RGBA, gl.UNSIGNED_BYTE, this._silhouettePixels\n            );\n\n            this._silhouetteImageData.data.set(this._silhouettePixels);\n            this._silhouette.update(this._silhouetteImageData, true /* isPremultiplied */);\n\n            this._silhouetteDirty = false;\n        }\n    }\n}\n\nmodule.exports = PenSkin;\n","class Rectangle {\n    /**\n     * A utility for creating and comparing axis-aligned rectangles.\n     * Rectangles are always initialized to the \"largest possible rectangle\";\n     * use one of the init* methods below to set up a particular rectangle.\n     * @constructor\n     */\n    constructor () {\n        this.left = -Infinity;\n        this.right = Infinity;\n        this.bottom = -Infinity;\n        this.top = Infinity;\n    }\n\n    /**\n     * Initialize a Rectangle from given Scratch-coordinate bounds.\n     * @param {number} left Left bound of the rectangle.\n     * @param {number} right Right bound of the rectangle.\n     * @param {number} bottom Bottom bound of the rectangle.\n     * @param {number} top Top bound of the rectangle.\n     */\n    initFromBounds (left, right, bottom, top) {\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n        this.top = top;\n    }\n\n    /**\n     * Initialize a Rectangle to the minimum AABB around a set of points.\n     * @param {Array<Array<number>>} points Array of [x, y] points.\n     */\n    initFromPointsAABB (points) {\n        this.left = Infinity;\n        this.right = -Infinity;\n        this.top = -Infinity;\n        this.bottom = Infinity;\n\n        for (let i = 0; i < points.length; i++) {\n            const x = points[i][0];\n            const y = points[i][1];\n            if (x < this.left) {\n                this.left = x;\n            }\n            if (x > this.right) {\n                this.right = x;\n            }\n            if (y > this.top) {\n                this.top = y;\n            }\n            if (y < this.bottom) {\n                this.bottom = y;\n            }\n        }\n    }\n\n    /**\n     * Initialize a Rectangle to a 1 unit square centered at 0 x 0 transformed\n     * by a model matrix.\n     * @param {Array.<number>} m A 4x4 matrix to transform the rectangle by.\n     * @tutorial Rectangle-AABB-Matrix\n     */\n    initFromModelMatrix (m) {\n        // In 2D space, we will soon use the 2x2 \"top left\" scale and rotation\n        // submatrix, while we store and the 1x2 \"top right\" that position\n        // vector.\n        const m30 = m[(3 * 4) + 0];\n        const m31 = m[(3 * 4) + 1];\n\n        // \"Transform\" a (0.5, 0.5) vector by the scale and rotation matrix but\n        // sum the absolute of each component instead of use the signed values.\n        const x = Math.abs(0.5 * m[(0 * 4) + 0]) + Math.abs(0.5 * m[(1 * 4) + 0]);\n        const y = Math.abs(0.5 * m[(0 * 4) + 1]) + Math.abs(0.5 * m[(1 * 4) + 1]);\n\n        // And adding them to the position components initializes our Rectangle.\n        this.left = -x + m30;\n        this.right = x + m30;\n        this.top = y + m31;\n        this.bottom = -y + m31;\n    }\n\n    /**\n     * Determine if this Rectangle intersects some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if intersecting.\n     * @return {boolean} True if this Rectangle intersects other.\n     */\n    intersects (other) {\n        return (\n            this.left <= other.right &&\n            other.left <= this.right &&\n            this.top >= other.bottom &&\n            other.top >= this.bottom\n        );\n    }\n\n    /**\n     * Determine if this Rectangle fully contains some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if fully contained.\n     * @return {boolean} True if this Rectangle fully contains other.\n     */\n    contains (other) {\n        return (\n            other.left > this.left &&\n            other.right < this.right &&\n            other.top < this.top &&\n            other.bottom > this.bottom\n        );\n    }\n\n    /**\n     * Clamp a Rectangle to bounds.\n     * @param {number} left Left clamp.\n     * @param {number} right Right clamp.\n     * @param {number} bottom Bottom clamp.\n     * @param {number} top Top clamp.\n     */\n    clamp (left, right, bottom, top) {\n        this.left = Math.max(this.left, left);\n        this.right = Math.min(this.right, right);\n        this.bottom = Math.max(this.bottom, bottom);\n        this.top = Math.min(this.top, top);\n        \n        this.left = Math.min(this.left, right);\n        this.right = Math.max(this.right, left);\n        this.bottom = Math.min(this.bottom, top);\n        this.top = Math.max(this.top, bottom);\n    }\n\n    /**\n     * Push out the Rectangle to integer bounds.\n     */\n    snapToInt () {\n        this.left = Math.floor(this.left);\n        this.right = Math.ceil(this.right);\n        this.bottom = Math.floor(this.bottom);\n        this.top = Math.ceil(this.top);\n    }\n\n    /**\n     * Compute the intersection of two bounding Rectangles.\n     * Could be an impossible box if they don't intersect.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static intersect (a, b, result = new Rectangle()) {\n        result.left = Math.max(a.left, b.left);\n        result.right = Math.min(a.right, b.right);\n        result.top = Math.min(a.top, b.top);\n        result.bottom = Math.max(a.bottom, b.bottom);\n\n        return result;\n    }\n\n    /**\n     * Compute the union of two bounding Rectangles.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static union (a, b, result = new Rectangle()) {\n        result.left = Math.min(a.left, b.left);\n        result.right = Math.max(a.right, b.right);\n        // Scratch Space - +y is up\n        result.top = Math.max(a.top, b.top);\n        result.bottom = Math.min(a.bottom, b.bottom);\n        return result;\n    }\n\n    /**\n     * Width of the Rectangle.\n     * @return {number} Width of rectangle.\n     */\n    get width () {\n        return Math.abs(this.left - this.right);\n    }\n\n    /**\n     * Height of the Rectangle.\n     * @return {number} Height of rectangle.\n     */\n    get height () {\n        return Math.abs(this.top - this.bottom);\n    }\n\n}\n\nmodule.exports = Rectangle;\n","/** @module RenderConstants */\n\n/**\n * Various constants meant for use throughout the renderer.\n * @enum\n */\nmodule.exports = {\n    /**\n     * The ID value to use for \"no item\" or when an object has been disposed.\n     * @const {int}\n     */\n    ID_NONE: -1,\n\n    /**\n     * Optimize for fewer than this number of Drawables sharing the same Skin.\n     * Going above this may cause middleware warnings or a performance penalty but should otherwise behave correctly.\n     * @const {int}\n     */\n    SKIN_SHARE_SOFT_LIMIT: 301,\n\n    /**\n     * @enum {string}\n     */\n    Events: {\n        /**\n         * NativeSizeChanged event\n         *\n         * @event RenderWebGL#event:NativeSizeChanged\n         * @type {object}\n         * @property {Array<int>} newSize - the new size of the renderer\n         */\n        NativeSizeChanged: 'NativeSizeChanged'\n    }\n};\n","const EventEmitter = require('events');\n\nconst hull = require('hull.js');\nconst twgl = require('twgl.js');\n\nconst BitmapSkin = require('./BitmapSkin');\nconst Drawable = require('./Drawable');\nconst Rectangle = require('./Rectangle');\nconst PenSkin = require('./PenSkin');\nconst RenderConstants = require('./RenderConstants');\nconst ShaderManager = require('./ShaderManager');\nconst SVGSkin = require('./SVGSkin');\nconst TextBubbleSkin = require('./TextBubbleSkin');\nconst EffectTransform = require('./EffectTransform');\nconst log = require('./util/log');\n\nconst __isTouchingDrawablesPoint = twgl.v3.create();\nconst __candidatesBounds = new Rectangle();\nconst __fenceBounds = new Rectangle();\nconst __touchingColor = new Uint8ClampedArray(4);\nconst __blendColor = new Uint8ClampedArray(4);\n\n// More pixels than this and we give up to the GPU and take the cost of readPixels\n// Width * Height * Number of drawables at location\nconst __cpuTouchingColorPixelCount = 4e4;\n\n/**\n * @callback RenderWebGL#idFilterFunc\n * @param {int} drawableID The ID to filter.\n * @return {bool} True if the ID passes the filter, otherwise false.\n */\n\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nconst MAX_TOUCH_SIZE = [3, 3];\n\n/**\n * Passed to the uniforms for mask in touching color\n */\nconst MASK_TOUCHING_COLOR_TOLERANCE = 2;\n\n/**\n * Maximum number of pixels in either dimension of \"extracted drawable\" data\n * @type {int}\n */\nconst MAX_EXTRACTED_DRAWABLE_DIMENSION = 2048;\n\n/**\n * Determines if the mask color is \"close enough\" (only test the 6 top bits for\n * each color).  These bit masks are what scratch 2 used to use, so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value.\n * @returns {boolean} If the colors match within the parameters.\n */\nconst maskMatches = (a, b) => (\n    // has some non-alpha component to test against\n    a[3] > 0 &&\n    (a[0] & 0b11111100) === (b[0] & 0b11111100) &&\n    (a[1] & 0b11111100) === (b[1] & 0b11111100) &&\n    (a[2] & 0b11111100) === (b[2] & 0b11111100)\n);\n\n/**\n * Determines if the given color is \"close enough\" (only test the 5 top bits for\n * red and green, 4 bits for blue).  These bit masks are what scratch 2 used to use,\n * so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value / or a larger array when used with offsets\n * @param {number} offset An offset into the `b` array, which lets you use a larger array to test\n *                  multiple values at the same time.\n * @returns {boolean} If the colors match within the parameters.\n */\nconst colorMatches = (a, b, offset) => (\n    (a[0] & 0b11111000) === (b[offset + 0] & 0b11111000) &&\n    (a[1] & 0b11111000) === (b[offset + 1] & 0b11111000) &&\n    (a[2] & 0b11110000) === (b[offset + 2] & 0b11110000)\n);\n\n/**\n * Sprite Fencing - The number of pixels a sprite is required to leave remaining\n * onscreen around the edge of the staging area.\n * @type {number}\n */\nconst FENCE_WIDTH = 15;\n\n\nclass RenderWebGL extends EventEmitter {\n    /**\n     * Check if this environment appears to support this renderer before attempting to create an instance.\n     * Catching an exception from the constructor is also a valid way to test for (lack of) support.\n     * @param {canvas} [optCanvas] - An optional canvas to use for the test. Otherwise a temporary canvas will be used.\n     * @returns {boolean} - True if this environment appears to support this renderer, false otherwise.\n     */\n    static isSupported (optCanvas) {\n        try {\n            // Create the context the same way that the constructor will: attributes may make the difference.\n            return !!RenderWebGL._getContext(optCanvas || document.createElement('canvas'));\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Ask TWGL to create a rendering context with the attributes used by this renderer.\n     * @param {canvas} canvas - attach the context to this canvas.\n     * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).\n     * @private\n     */\n    static _getContext (canvas) {\n        const contextAttribs = {alpha: false, stencil: true, antialias: false};\n        // getWebGLContext = try WebGL 1.0 only\n        // getContext = try WebGL 2.0 and if that doesn't work, try WebGL 1.0\n        // getWebGLContext || getContext = try WebGL 1.0 and if that doesn't work, try WebGL 2.0\n        return twgl.getWebGLContext(canvas, contextAttribs) ||\n            twgl.getContext(canvas, contextAttribs);\n    }\n\n    /**\n     * Create a renderer for drawing Scratch sprites to a canvas using WebGL.\n     * Coordinates will default to Scratch 2.0 values if unspecified.\n     * The stage's \"native\" size will be calculated from the these coordinates.\n     * For example, the defaults result in a native size of 480x360.\n     * Queries such as \"touching color?\" will always execute at the native size.\n     * @see RenderWebGL#setStageSize\n     * @see RenderWebGL#resize\n     * @param {canvas} canvas The canvas to draw onto.\n     * @param {int} [xLeft=-240] The x-coordinate of the left edge.\n     * @param {int} [xRight=240] The x-coordinate of the right edge.\n     * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.\n     * @param {int} [yTop=180] The y-coordinate of the top edge.\n     * @constructor\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (canvas, xLeft, xRight, yBottom, yTop) {\n        super();\n\n        /** @type {WebGLRenderingContext} */\n        const gl = this._gl = RenderWebGL._getContext(canvas);\n        if (!gl) {\n            throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n        }\n\n        /** @type {RenderWebGL.UseGpuModes} */\n        this._useGpuMode = RenderWebGL.UseGpuModes.Automatic;\n\n        /** @type {Drawable[]} */\n        this._allDrawables = [];\n\n        /** @type {Skin[]} */\n        this._allSkins = [];\n\n        /** @type {Array<int>} */\n        this._drawList = [];\n\n        // A list of layer group names in the order they should appear\n        // from furthest back to furthest in front.\n        /** @type {Array<String>} */\n        this._groupOrdering = [];\n\n        /**\n         * @typedef LayerGroup\n         * @property {int} groupIndex The relative position of this layer group in the group ordering\n         * @property {int} drawListOffset The absolute position of this layer group in the draw list\n         * This number gets updated as drawables get added to or deleted from the draw list.\n         */\n\n        // Map of group name to layer group\n        /** @type {Object.<string, LayerGroup>} */\n        this._layerGroups = {};\n\n        /** @type {int} */\n        this._nextDrawableId = RenderConstants.ID_NONE + 1;\n\n        /** @type {int} */\n        this._nextSkinId = RenderConstants.ID_NONE + 1;\n\n        /** @type {module:twgl/m4.Mat4} */\n        this._projection = twgl.m4.identity();\n\n        /** @type {ShaderManager} */\n        this._shaderManager = new ShaderManager(gl);\n\n        /** @type {HTMLCanvasElement} */\n        this._tempCanvas = document.createElement('canvas');\n\n        /** @type {any} */\n        this._regionId = null;\n\n        /** @type {function} */\n        this._exitRegion = null;\n\n        /** @type {object} */\n        this._backgroundDrawRegionId = {\n            enter: () => this._enterDrawBackground(),\n            exit: () => this._exitDrawBackground()\n        };\n\n        /** @type {Array.<snapshotCallback>} */\n        this._snapshotCallbacks = [];\n\n        /** @type {Array<number>} */\n        // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor3b\n        this._backgroundColor4f = [0, 0, 0, 1];\n\n        /** @type {Uint8ClampedArray} */\n        // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor4f\n        this._backgroundColor3b = new Uint8ClampedArray(3);\n\n        this._createGeometry();\n\n        this.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this.setBackgroundColor(1, 1, 1);\n        this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n        this.resize(this._nativeSize[0], this._nativeSize[1]);\n\n        gl.disable(gl.DEPTH_TEST);\n        /** @todo disable when no partial transparency? */\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    }\n\n    /**\n     * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.\n     */\n    get gl () {\n        return this._gl;\n    }\n\n    /**\n     * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.\n     */\n    get canvas () {\n        return this._gl && this._gl.canvas;\n    }\n\n    /**\n     * Set the physical size of the stage in device-independent pixels.\n     * This will be multiplied by the device's pixel ratio on high-DPI displays.\n     * @param {int} pixelsWide The desired width in device-independent pixels.\n     * @param {int} pixelsTall The desired height in device-independent pixels.\n     */\n    resize (pixelsWide, pixelsTall) {\n        const {canvas} = this._gl;\n        const pixelRatio = window.devicePixelRatio || 1;\n        const newWidth = pixelsWide * pixelRatio;\n        const newHeight = pixelsTall * pixelRatio;\n\n        // Certain operations, such as moving the color picker, call `resize` once per frame, even though the canvas\n        // size doesn't change. To avoid unnecessary canvas updates, check that we *really* need to resize the canvas.\n        if (canvas.width !== newWidth || canvas.height !== newHeight) {\n            canvas.width = newWidth;\n            canvas.height = newHeight;\n            // Resizing the canvas causes it to be cleared, so redraw it.\n            this.draw();\n        }\n\n    }\n\n    /**\n     * Set the background color for the stage. The stage will be cleared with this\n     * color each frame.\n     * @param {number} red The red component for the background.\n     * @param {number} green The green component for the background.\n     * @param {number} blue The blue component for the background.\n     */\n    setBackgroundColor (red, green, blue) {\n        this._backgroundColor4f[0] = red;\n        this._backgroundColor4f[1] = green;\n        this._backgroundColor4f[2] = blue;\n\n        this._backgroundColor3b[0] = red * 255;\n        this._backgroundColor3b[1] = green * 255;\n        this._backgroundColor3b[2] = blue * 255;\n\n    }\n\n    /**\n     * Tell the renderer to draw various debug information to the provided canvas\n     * during certain operations.\n     * @param {canvas} canvas The canvas to use for debug output.\n     */\n    setDebugCanvas (canvas) {\n        this._debugCanvas = canvas;\n    }\n\n    /**\n     * Control the use of the GPU or CPU paths in `isTouchingColor`.\n     * @param {RenderWebGL.UseGpuModes} useGpuMode - automatically decide, force CPU, or force GPU.\n     */\n    setUseGpuMode (useGpuMode) {\n        this._useGpuMode = useGpuMode;\n    }\n\n    /**\n     * Set logical size of the stage in Scratch units.\n     * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.\n     * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.\n     * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.\n     * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.\n     */\n    setStageSize (xLeft, xRight, yBottom, yTop) {\n        this._xLeft = xLeft;\n        this._xRight = xRight;\n        this._yBottom = yBottom;\n        this._yTop = yTop;\n\n        // swap yBottom & yTop to fit Scratch convention of +y=up\n        this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n\n        this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n\n    /**\n     * @return {Array<int>} the \"native\" size of the stage, which is used for pen, query renders, etc.\n     */\n    getNativeSize () {\n        return [this._nativeSize[0], this._nativeSize[1]];\n    }\n\n    /**\n     * Set the \"native\" size of the stage, which is used for pen, query renders, etc.\n     * @param {int} width - the new width to set.\n     * @param {int} height - the new height to set.\n     * @private\n     * @fires RenderWebGL#event:NativeSizeChanged\n     */\n    _setNativeSize (width, height) {\n        this._nativeSize = [width, height];\n        this.emit(RenderConstants.Events.NativeSizeChanged, {newSize: this._nativeSize});\n    }\n\n    /**\n     * Create a new bitmap skin from a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n     * the skin will be used.\n     * @returns {!int} the ID for the new skin.\n     */\n    createBitmapSkin (bitmapData, costumeResolution, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new BitmapSkin(skinId, this);\n        newSkin.setBitmap(bitmapData, costumeResolution, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new SVG skin.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     * @returns {!int} the ID for the new skin.\n     */\n    createSVGSkin (svgData, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new PenSkin - a skin which implements a Scratch pen layer.\n     * @returns {!int} the ID for the new skin.\n     */\n    createPenSkin () {\n        const skinId = this._nextSkinId++;\n        const newSkin = new PenSkin(skinId, this);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new SVG skin using the text bubble svg creator. The rotation center\n     * is always placed at the top left.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     * @returns {!int} the ID for the new skin.\n     */\n    createTextSkin (type, text, pointsLeft) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new TextBubbleSkin(skinId, this);\n        newSkin.setTextBubble(type, text, pointsLeft);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Update an existing SVG skin, or create an SVG skin if the previous skin was not SVG.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n    updateSVGSkin (skinId, svgData, rotationCenter) {\n        if (this._allSkins[skinId] instanceof SVGSkin) {\n            this._allSkins[skinId].setSVG(svgData, rotationCenter);\n            return;\n        }\n\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._reskin(skinId, newSkin);\n    }\n\n    /**\n     * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n     * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n    updateBitmapSkin (skinId, imgData, bitmapResolution, rotationCenter) {\n        if (this._allSkins[skinId] instanceof BitmapSkin) {\n            this._allSkins[skinId].setBitmap(imgData, bitmapResolution, rotationCenter);\n            return;\n        }\n\n        const newSkin = new BitmapSkin(skinId, this);\n        newSkin.setBitmap(imgData, bitmapResolution, rotationCenter);\n        this._reskin(skinId, newSkin);\n    }\n\n    _reskin (skinId, newSkin) {\n        const oldSkin = this._allSkins[skinId];\n        this._allSkins[skinId] = newSkin;\n\n        // Tell drawables to update\n        for (const drawable of this._allDrawables) {\n            if (drawable && drawable.skin === oldSkin) {\n                drawable.skin = newSkin;\n            }\n        }\n        oldSkin.dispose();\n    }\n\n    /**\n     * Update a skin using the text bubble svg creator.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     */\n    updateTextSkin (skinId, type, text, pointsLeft) {\n        if (this._allSkins[skinId] instanceof TextBubbleSkin) {\n            this._allSkins[skinId].setTextBubble(type, text, pointsLeft);\n            return;\n        }\n\n        const newSkin = new TextBubbleSkin(skinId, this);\n        newSkin.setTextBubble(type, text, pointsLeft);\n        this._reskin(skinId, newSkin);\n    }\n\n\n    /**\n     * Destroy an existing skin. Do not use the skin or its ID after calling this.\n     * @param {!int} skinId - The ID of the skin to destroy.\n     */\n    destroySkin (skinId) {\n        const oldSkin = this._allSkins[skinId];\n        oldSkin.dispose();\n        delete this._allSkins[skinId];\n    }\n\n    /**\n     * Create a new Drawable and add it to the scene.\n     * @param {string} group Layer group to add the drawable to\n     * @returns {int} The ID of the new Drawable.\n     */\n    createDrawable (group) {\n        if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n            log.warn('Cannot create a drawable without a known layer group');\n            return;\n        }\n        const drawableID = this._nextDrawableId++;\n        const drawable = new Drawable(drawableID);\n        this._allDrawables[drawableID] = drawable;\n        this._addToDrawList(drawableID, group);\n\n        drawable.skin = null;\n\n        return drawableID;\n    }\n\n    /**\n     * Set the layer group ordering for the renderer.\n     * @param {Array<string>} groupOrdering The ordered array of layer group\n     * names\n     */\n    setLayerGroupOrdering (groupOrdering) {\n        this._groupOrdering = groupOrdering;\n        for (let i = 0; i < this._groupOrdering.length; i++) {\n            this._layerGroups[this._groupOrdering[i]] = {\n                groupIndex: i,\n                drawListOffset: 0\n            };\n        }\n    }\n\n    _addToDrawList (drawableID, group) {\n        const currentLayerGroup = this._layerGroups[group];\n        const currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n\n        const drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n        this._drawList.splice(drawListOffset, 0, drawableID);\n\n        this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n\n    _updateOffsets (updateType, currentGroupOrderingIndex) {\n        for (let i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n            const laterGroupName = this._groupOrdering[i];\n            if (updateType === 'add') {\n                this._layerGroups[laterGroupName].drawListOffset++;\n            } else if (updateType === 'delete'){\n                this._layerGroups[laterGroupName].drawListOffset--;\n            }\n        }\n    }\n\n    get _visibleDrawList () {\n        return this._drawList.filter(id => this._allDrawables[id]._visible);\n    }\n\n    // Given a layer group, return the index where it ends (non-inclusive),\n    // e.g. the returned index does not have a drawable from this layer group in it)\n    _endIndexForKnownLayerGroup (layerGroup) {\n        const groupIndex = layerGroup.groupIndex;\n        if (groupIndex === this._groupOrdering.length - 1) {\n            return this._drawList.length;\n        }\n        return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n\n    /**\n     * Destroy a Drawable, removing it from the scene.\n     * @param {int} drawableID The ID of the Drawable to remove.\n     * @param {string} group Group name that the drawable belongs to\n     */\n    destroyDrawable (drawableID, group) {\n        if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n            log.warn('Cannot destroy drawable without known layer group.');\n            return;\n        }\n        const drawable = this._allDrawables[drawableID];\n        drawable.dispose();\n        delete this._allDrawables[drawableID];\n\n        const currentLayerGroup = this._layerGroups[group];\n        const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n\n        let index = currentLayerGroup.drawListOffset;\n        while (index < endIndex) {\n            if (this._drawList[index] === drawableID) {\n                break;\n            }\n            index++;\n        }\n        if (index < endIndex) {\n            this._drawList.splice(index, 1);\n            this._updateOffsets('delete', currentLayerGroup.groupIndex);\n        } else {\n            log.warn('Could not destroy drawable that could not be found in layer group.');\n            return;\n        }\n    }\n\n    /**\n     * Returns the position of the given drawableID in the draw list. This is\n     * the absolute position irrespective of layer group.\n     * @param {number} drawableID The drawable ID to find.\n     * @return {number} The postion of the given drawable ID.\n     */\n    getDrawableOrder (drawableID) {\n        return this._drawList.indexOf(drawableID);\n    }\n\n    /**\n     * Set a drawable's order in the drawable list (effectively, z/layer).\n     * Can be used to move drawables to absolute positions in the list,\n     * or relative to their current positions.\n     * \"go back N layers\": setDrawableOrder(id, -N, true, 1); (assuming stage at 0).\n     * \"go to back\": setDrawableOrder(id, 1); (assuming stage at 0).\n     * \"go to front\": setDrawableOrder(id, Infinity);\n     * @param {int} drawableID ID of Drawable to reorder.\n     * @param {number} order New absolute order or relative order adjusment.\n     * @param {string=} group Name of layer group drawable belongs to.\n     * Reordering will not take place if drawable cannot be found within the bounds\n     * of the layer group.\n     * @param {boolean=} optIsRelative If set, `order` refers to a relative change.\n     * @param {number=} optMin If set, order constrained to be at least `optMin`.\n     * @return {?number} New order if changed, or null.\n     */\n    setDrawableOrder (drawableID, order, group, optIsRelative, optMin) {\n        if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {\n            log.warn('Cannot set the order of a drawable without a known layer group.');\n            return;\n        }\n\n        const currentLayerGroup = this._layerGroups[group];\n        const startIndex = currentLayerGroup.drawListOffset;\n        const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n\n        let oldIndex = startIndex;\n        while (oldIndex < endIndex) {\n            if (this._drawList[oldIndex] === drawableID) {\n                break;\n            }\n            oldIndex++;\n        }\n\n        if (oldIndex < endIndex) {\n            // Remove drawable from the list.\n            if (order === 0) {\n                return oldIndex;\n            }\n\n            const _ = this._drawList.splice(oldIndex, 1)[0];\n            // Determine new index.\n            let newIndex = order;\n            if (optIsRelative) {\n                newIndex += oldIndex;\n            }\n\n            const possibleMin = (optMin || 0) + startIndex;\n            const min = (possibleMin >= startIndex && possibleMin < endIndex) ? possibleMin : startIndex;\n            newIndex = Math.max(newIndex, min);\n\n            newIndex = Math.min(newIndex, endIndex);\n\n            // Insert at new index.\n            this._drawList.splice(newIndex, 0, drawableID);\n            return newIndex;\n        }\n\n        return null;\n    }\n\n    /**\n     * Draw all current drawables and present the frame on the canvas.\n     */\n    draw () {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n\n        twgl.bindFramebufferInfo(gl, null);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor(...this._backgroundColor4f);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection, {\n            framebufferWidth: gl.canvas.width,\n            framebufferHeight: gl.canvas.height\n        });\n        if (this._snapshotCallbacks.length > 0) {\n            const snapshot = gl.canvas.toDataURL();\n            this._snapshotCallbacks.forEach(cb => cb(snapshot));\n            this._snapshotCallbacks = [];\n        }\n    }\n\n    /**\n     * Get the precise bounds for a Drawable.\n     * @param {int} drawableID ID of Drawable to get bounds for.\n     * @return {object} Bounds for a tight box around the Drawable.\n     */\n    getBounds (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        // Tell the Drawable about its updated convex hull, if necessary.\n        if (drawable.needsConvexHullPoints()) {\n            const points = this._getConvexHullPointsForDrawable(drawableID);\n            drawable.setConvexHullPoints(points);\n        }\n        const bounds = drawable.getFastBounds();\n        // In debug mode, draw the bounds.\n        if (this._debugCanvas) {\n            const gl = this._gl;\n            this._debugCanvas.width = gl.canvas.width;\n            this._debugCanvas.height = gl.canvas.height;\n            const context = this._debugCanvas.getContext('2d');\n            context.drawImage(gl.canvas, 0, 0);\n            context.strokeStyle = '#FF0000';\n            const pr = window.devicePixelRatio;\n            context.strokeRect(\n                pr * (bounds.left + (this._nativeSize[0] / 2)),\n                pr * (-bounds.top + (this._nativeSize[1] / 2)),\n                pr * (bounds.right - bounds.left),\n                pr * (-bounds.bottom + bounds.top)\n            );\n        }\n        return bounds;\n    }\n\n    /**\n     * Get the precise bounds for a Drawable around the top slice.\n     * Used for positioning speech bubbles more closely to the sprite.\n     * @param {int} drawableID ID of Drawable to get bubble bounds for.\n     * @return {object} Bounds for a tight box around the Drawable top slice.\n     */\n    getBoundsForBubble (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        // Tell the Drawable about its updated convex hull, if necessary.\n        if (drawable.needsConvexHullPoints()) {\n            const points = this._getConvexHullPointsForDrawable(drawableID);\n            drawable.setConvexHullPoints(points);\n        }\n        const bounds = drawable.getBoundsForBubble();\n        // In debug mode, draw the bounds.\n        if (this._debugCanvas) {\n            const gl = this._gl;\n            this._debugCanvas.width = gl.canvas.width;\n            this._debugCanvas.height = gl.canvas.height;\n            const context = this._debugCanvas.getContext('2d');\n            context.drawImage(gl.canvas, 0, 0);\n            context.strokeStyle = '#FF0000';\n            const pr = window.devicePixelRatio;\n            context.strokeRect(\n                pr * (bounds.left + (this._nativeSize[0] / 2)),\n                pr * (-bounds.top + (this._nativeSize[1] / 2)),\n                pr * (bounds.right - bounds.left),\n                pr * (-bounds.bottom + bounds.top)\n            );\n        }\n        return bounds;\n    }\n\n    /**\n     * Get the current skin (costume) size of a Drawable.\n     * @param {int} drawableID The ID of the Drawable to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n    getCurrentSkinSize (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        return this.getSkinSize(drawable.skin.id);\n    }\n\n    /**\n     * Get the size of a skin by ID.\n     * @param {int} skinID The ID of the Skin to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n    getSkinSize (skinID) {\n        const skin = this._allSkins[skinID];\n        return skin.size;\n    }\n\n    /**\n     * Get the rotation center of a skin by ID.\n     * @param {int} skinID The ID of the Skin\n     * @return {Array<number>} The rotationCenterX and rotationCenterY\n     */\n    getSkinRotationCenter (skinID) {\n        const skin = this._allSkins[skinID];\n        return skin.calculateRotationCenter();\n    }\n\n    /**\n     * Check if a particular Drawable is touching a particular color.\n     * Unlike touching drawable, if the \"tester\" is invisble, we will still test.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {Array<int>} color3b Test if the Drawable is touching this color.\n     * @param {Array<int>} [mask3b] Optionally mask the check to this part of Drawable.\n     * @returns {boolean} True iff the Drawable is touching the color.\n     */\n    isTouchingColor (drawableID, color3b, mask3b) {\n        const candidates = this._candidatesTouching(drawableID, this._visibleDrawList);\n\n        let bounds;\n        if (colorMatches(color3b, this._backgroundColor3b, 0)) {\n            // If the color we're checking for is the background color, don't confine the check to\n            // candidate drawables' bounds--since the background spans the entire stage, we must check\n            // everything that lies inside the drawable.\n            bounds = this._touchingBounds(drawableID);\n            // e.g. empty costume, or off the stage\n            if (bounds === null) return false;\n        } else if (candidates.length === 0) {\n            // If not checking for the background color, we can return early if there are no candidate drawables.\n            return false;\n        } else {\n            bounds = this._candidatesBounds(candidates);\n        }\n\n        const maxPixelsForCPU = this._getMaxPixelsForCPU();\n\n        const debugCanvasContext = this._debugCanvas && this._debugCanvas.getContext('2d');\n        if (debugCanvasContext) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n        }\n\n        // if there are just too many pixels to CPU render efficiently, we need to let readPixels happen\n        if (bounds.width * bounds.height * (candidates.length + 1) >= maxPixelsForCPU) {\n            this._isTouchingColorGpuStart(drawableID, candidates.map(({id}) => id).reverse(), bounds, color3b, mask3b);\n        }\n\n        const drawable = this._allDrawables[drawableID];\n        const point = __isTouchingDrawablesPoint;\n        const color = __touchingColor;\n        const hasMask = Boolean(mask3b);\n\n        drawable.updateCPURenderAttributes();\n\n        // Masked drawable ignores ghost effect\n        const effectMask = ~ShaderManager.EFFECT_INFO.ghost.mask;\n\n        // Scratch Space - +y is top\n        for (let y = bounds.bottom; y <= bounds.top; y++) {\n            if (bounds.width * (y - bounds.bottom) * (candidates.length + 1) >= maxPixelsForCPU) {\n                return this._isTouchingColorGpuFin(bounds, color3b, y - bounds.bottom);\n            }\n            for (let x = bounds.left; x <= bounds.right; x++) {\n                point[1] = y;\n                point[0] = x;\n                // if we use a mask, check our sample color...\n                if (hasMask ?\n                    maskMatches(Drawable.sampleColor4b(point, drawable, color, effectMask), mask3b) :\n                    drawable.isTouching(point)) {\n                    RenderWebGL.sampleColor3b(point, candidates, color);\n                    if (debugCanvasContext) {\n                        debugCanvasContext.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;\n                        debugCanvasContext.fillRect(x - bounds.left, bounds.bottom - y, 1, 1);\n                    }\n                    // ...and the target color is drawn at this pixel\n                    if (colorMatches(color, color3b, 0)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    _getMaxPixelsForCPU () {\n        switch (this._useGpuMode) {\n        case RenderWebGL.UseGpuModes.ForceCPU:\n            return Infinity;\n        case RenderWebGL.UseGpuModes.ForceGPU:\n            return 0;\n        case RenderWebGL.UseGpuModes.Automatic:\n        default:\n            return __cpuTouchingColorPixelCount;\n        }\n    }\n\n    _enterDrawBackground () {\n        const gl = this.gl;\n        const currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n        gl.disable(gl.BLEND);\n        gl.useProgram(currentShader.program);\n        twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n    }\n\n    _exitDrawBackground () {\n        const gl = this.gl;\n        gl.enable(gl.BLEND);\n    }\n\n    _isTouchingColorGpuStart (drawableID, candidateIDs, bounds, color3b, mask3b) {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        // Limit size of viewport to the bounds around the target Drawable,\n        // and create the projection matrix for the draw.\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        // Clear the query buffer to fully transparent. This will be the color of pixels that fail the stencil test.\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n        let extraUniforms;\n        if (mask3b) {\n            extraUniforms = {\n                u_colorMask: [mask3b[0] / 255, mask3b[1] / 255, mask3b[2] / 255],\n                u_colorMaskTolerance: MASK_TOUCHING_COLOR_TOLERANCE / 255\n            };\n        }\n\n        try {\n            // Using the stencil buffer, mask out the drawing to either the drawable's alpha channel\n            // or pixels of the drawable which match the mask color, depending on whether a mask color is given.\n            // Masked-out pixels will not be checked.\n            gl.enable(gl.STENCIL_TEST);\n            gl.stencilFunc(gl.ALWAYS, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n            gl.colorMask(false, false, false, false);\n            this._drawThese(\n                [drawableID],\n                mask3b ?\n                    ShaderManager.DRAW_MODE.colorMask :\n                    ShaderManager.DRAW_MODE.silhouette,\n                projection,\n                {\n                    extraUniforms,\n                    ignoreVisibility: true, // Touching color ignores sprite visibility,\n                    effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask\n                });\n\n            gl.stencilFunc(gl.EQUAL, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n            gl.colorMask(true, true, true, true);\n\n            // Draw the background as a quad. Drawing a background with gl.clear will not mask to the stenciled area.\n            this.enterDrawRegion(this._backgroundDrawRegionId);\n\n            const uniforms = {\n                u_backgroundColor: this._backgroundColor4f\n            };\n\n            const currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);\n            twgl.setUniforms(currentShader, uniforms);\n            twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n\n            // Draw the candidate drawables on top of the background.\n            this._drawThese(candidateIDs, ShaderManager.DRAW_MODE.default, projection,\n                {idFilterFunc: testID => testID !== drawableID}\n            );\n        } finally {\n            gl.colorMask(true, true, true, true);\n            gl.disable(gl.STENCIL_TEST);\n            this._doExitDrawRegion();\n        }\n    }\n\n    _isTouchingColorGpuFin (bounds, color3b, stop) {\n        const gl = this._gl;\n        const pixels = new Uint8Array(Math.floor(bounds.width * (bounds.height - stop) * 4));\n        gl.readPixels(0, 0, bounds.width, (bounds.height - stop), gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n        if (this._debugCanvas) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n            const context = this._debugCanvas.getContext('2d');\n            const imageData = context.getImageData(0, 0, bounds.width, bounds.height - stop);\n            imageData.data.set(pixels);\n            context.putImageData(imageData, 0, 0);\n        }\n\n        for (let pixelBase = 0; pixelBase < pixels.length; pixelBase += 4) {\n            // Transparent pixels are masked (either by the drawable's alpha channel or color mask).\n            if (pixels[pixelBase + 3] !== 0 && colorMatches(color3b, pixels, pixelBase)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a particular Drawable is touching any in a set of Drawables.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {?Array<int>} candidateIDs The Drawable IDs to check, otherwise all visible drawables in the renderer\n     * @returns {boolean} True if the Drawable is touching one of candidateIDs.\n     */\n    isTouchingDrawables (drawableID, candidateIDs = this._drawList) {\n        const candidates = this._candidatesTouching(drawableID,\n            // even if passed an invisible drawable, we will NEVER touch it!\n            candidateIDs.filter(id => this._allDrawables[id]._visible));\n        // if we are invisble we don't touch anything.\n        if (candidates.length === 0 || !this._allDrawables[drawableID]._visible) {\n            return false;\n        }\n\n        // Get the union of all the candidates intersections.\n        const bounds = this._candidatesBounds(candidates);\n\n        const drawable = this._allDrawables[drawableID];\n        const point = __isTouchingDrawablesPoint;\n\n        drawable.updateCPURenderAttributes();\n\n        // This is an EXTREMELY brute force collision detector, but it is\n        // still faster than asking the GPU to give us the pixels.\n        for (let x = bounds.left; x <= bounds.right; x++) {\n            // Scratch Space - +y is top\n            point[0] = x;\n            for (let y = bounds.bottom; y <= bounds.top; y++) {\n                point[1] = y;\n                if (drawable.isTouching(point)) {\n                    for (let index = 0; index < candidates.length; index++) {\n                        if (candidates[index].drawable.isTouching(point)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Convert a client based x/y position on the canvas to a Scratch 3 world space\n     * Rectangle.  This creates recangles with a radius to cover selecting multiple\n     * scratch pixels with touch / small render areas.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [width] The client width of the touch event (optional).\n     * @param {int} [height] The client width of the touch event (optional).\n     * @returns {Rectangle} Scratch world space rectangle, iterate bottom <= top,\n     *                      left <= right.\n     */\n    clientSpaceToScratchBounds (centerX, centerY, width = 1, height = 1) {\n        const gl = this._gl;\n\n        const clientToScratchX = this._nativeSize[0] / gl.canvas.clientWidth;\n        const clientToScratchY = this._nativeSize[1] / gl.canvas.clientHeight;\n\n        width *= clientToScratchX;\n        height *= clientToScratchY;\n\n        width = Math.max(1, Math.min(Math.round(width), MAX_TOUCH_SIZE[0]));\n        height = Math.max(1, Math.min(Math.round(height), MAX_TOUCH_SIZE[1]));\n        const x = (centerX * clientToScratchX) - ((width - 1) / 2);\n        // + because scratch y is inverted\n        const y = (centerY * clientToScratchY) + ((height - 1) / 2);\n\n        const xOfs = (width % 2) ? 0 : -0.5;\n        // y is offset +0.5\n        const yOfs = (height % 2) ? 0 : -0.5;\n\n        const bounds = new Rectangle();\n        bounds.initFromBounds(Math.floor(this._xLeft + x + xOfs), Math.floor(this._xLeft + x + xOfs + width - 1),\n            Math.ceil(this._yTop - y + yOfs), Math.ceil(this._yTop - y + yOfs + height - 1));\n        return bounds;\n    }\n\n    /**\n     * Determine if the drawable is touching a client based x/y.  Helper method for sensing\n     * touching mouse-pointer.  Ignores visibility.\n     *\n     * @param {int} drawableID The ID of the drawable to check.\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @returns {boolean} If the drawable has any pixels that would draw in the touch area\n     */\n    drawableTouching (drawableID, centerX, centerY, touchWidth, touchHeight) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            return false;\n        }\n        const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n        const worldPos = twgl.v3.create();\n\n        drawable.updateCPURenderAttributes();\n\n        for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n            for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n                if (drawable.isTouching(worldPos)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Detect which sprite, if any, is at the given location.\n     * This function will pick all drawables that are visible, unless specific\n     * candidate drawable IDs are provided.  Used for determining what is clicked\n     * or dragged.  Will not select hidden / ghosted sprites.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @param {Array<int>} [candidateIDs] The Drawable IDs to pick from, otherwise all visible drawables.\n     * @returns {int} The ID of the topmost Drawable under the picking location, or\n     * RenderConstants.ID_NONE if there is no Drawable at that location.\n     */\n    pick (centerX, centerY, touchWidth, touchHeight, candidateIDs) {\n        const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n        if (bounds.left === -Infinity || bounds.bottom === -Infinity) {\n            return false;\n        }\n\n        candidateIDs = (candidateIDs || this._drawList).filter(id => {\n            const drawable = this._allDrawables[id];\n            // default pick list ignores visible and ghosted sprites.\n            if (drawable.getVisible() && drawable.getUniforms().u_ghost !== 0) {\n                const drawableBounds = drawable.getFastBounds();\n                const inRange = bounds.intersects(drawableBounds);\n                if (!inRange) return false;\n\n                drawable.updateCPURenderAttributes();\n                return true;\n            }\n            return false;\n        });\n        if (candidateIDs.length === 0) {\n            return false;\n        }\n\n        const hits = [];\n        const worldPos = twgl.v3.create(0, 0, 0);\n        // Iterate over the scratch pixels and check if any candidate can be\n        // touched at that point.\n        for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n            for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n\n                // Check candidates in the reverse order they would have been\n                // drawn. This will determine what candiate's silhouette pixel\n                // would have been drawn at the point.\n                for (let d = candidateIDs.length - 1; d >= 0; d--) {\n                    const id = candidateIDs[d];\n                    const drawable = this._allDrawables[id];\n                    if (drawable.isTouching(worldPos)) {\n                        hits[id] = (hits[id] || 0) + 1;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Bias toward selecting anything over nothing\n        hits[RenderConstants.ID_NONE] = 0;\n\n        let hit = RenderConstants.ID_NONE;\n        for (const hitID in hits) {\n            if (Object.prototype.hasOwnProperty.call(hits, hitID) && (hits[hitID] > hits[hit])) {\n                hit = hitID;\n            }\n        }\n\n        return Number(hit);\n    }\n\n    /**\n     * @typedef DrawableExtraction\n     * @property {ImageData} data Raw pixel data for the drawable\n     * @property {number} x The x coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'\n     * @property {number} y The y coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'\n     * @property {number} width The drawable's bounding box width, in 'CSS pixels'\n     * @property {number} height The drawable's bounding box height, in 'CSS pixels'\n     */\n\n    /**\n     * Return a drawable's pixel data and bounds in screen space.\n     * @param {int} drawableID The ID of the drawable to get pixel data for\n     * @return {DrawableExtraction} Data about the picked drawable\n     */\n    extractDrawableScreenSpace (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) throw new Error(`Could not extract drawable with ID ${drawableID}; it does not exist`);\n\n        this._doExitDrawRegion();\n\n        const nativeCenterX = this._nativeSize[0] * 0.5;\n        const nativeCenterY = this._nativeSize[1] * 0.5;\n\n        const scratchBounds = drawable.getFastBounds();\n\n        const canvas = this.canvas;\n        // Ratio of the screen-space scale of the stage's canvas to the \"native size\" of the stage\n        const scaleFactor = canvas.width / this._nativeSize[0];\n\n        // Bounds of the extracted drawable, in \"canvas pixel space\"\n        // (origin is 0, 0, destination is the canvas width, height).\n        const canvasSpaceBounds = new Rectangle();\n        canvasSpaceBounds.initFromBounds(\n            (scratchBounds.left + nativeCenterX) * scaleFactor,\n            (scratchBounds.right + nativeCenterX) * scaleFactor,\n            // in \"canvas space\", +y is down, but Rectangle methods assume bottom < top, so swap them\n            (nativeCenterY - scratchBounds.top) * scaleFactor,\n            (nativeCenterY - scratchBounds.bottom) * scaleFactor\n        );\n        canvasSpaceBounds.snapToInt();\n\n        // undo the transformation to transform the bounds, snapped to \"canvas-pixel space\", back to \"Scratch space\"\n        // We have to transform -> snap -> invert transform so that the \"Scratch-space\" bounds are snapped in\n        // \"canvas-pixel space\".\n        scratchBounds.initFromBounds(\n            (canvasSpaceBounds.left / scaleFactor) - nativeCenterX,\n            (canvasSpaceBounds.right / scaleFactor) - nativeCenterX,\n            nativeCenterY - (canvasSpaceBounds.top / scaleFactor),\n            nativeCenterY - (canvasSpaceBounds.bottom / scaleFactor)\n        );\n\n        const gl = this._gl;\n\n        // Set a reasonable max limit width and height for the bufferInfo bounds\n        const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n        const clampedWidth = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.width, maxTextureSize);\n        const clampedHeight = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.height, maxTextureSize);\n\n        // Make a new bufferInfo since this._queryBufferInfo is limited to 480x360\n        const bufferInfo = twgl.createFramebufferInfo(gl, [{format: gl.RGBA}], clampedWidth, clampedHeight);\n\n        try {\n            twgl.bindFramebufferInfo(gl, bufferInfo);\n\n            // Limit size of viewport to the bounds around the target Drawable,\n            // and create the projection matrix for the draw.\n            gl.viewport(0, 0, clampedWidth, clampedHeight);\n            const projection = twgl.m4.ortho(\n                scratchBounds.left,\n                scratchBounds.right,\n                scratchBounds.top,\n                scratchBounds.bottom,\n                -1, 1\n            );\n\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection,\n                {\n                    // Don't apply the ghost effect. TODO: is this an intentional design decision?\n                    effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask,\n                    // We're doing this in screen-space, so the framebuffer dimensions should be those of the canvas in\n                    // screen-space. This is used to ensure SVG skins are rendered at the proper resolution.\n                    framebufferWidth: canvas.width,\n                    framebufferHeight: canvas.height\n                });\n\n            const data = new Uint8Array(Math.floor(clampedWidth * clampedHeight * 4));\n            gl.readPixels(0, 0, clampedWidth, clampedHeight, gl.RGBA, gl.UNSIGNED_BYTE, data);\n            // readPixels can only read into a Uint8Array, but ImageData has to take a Uint8ClampedArray.\n            // We can share the same underlying buffer between them to avoid having to copy any data.\n            const imageData = new ImageData(new Uint8ClampedArray(data.buffer), clampedWidth, clampedHeight);\n\n            // On high-DPI devices, the canvas' width (in canvas pixels) will be larger than its width in CSS pixels.\n            // We want to return the CSS-space bounds,\n            // so take into account the ratio between the canvas' pixel dimensions and its layout dimensions.\n            // This is usually the same as 1 / window.devicePixelRatio, but if e.g. you zoom your browser window without\n            // the canvas resizing, then it'll differ.\n            const ratio = canvas.getBoundingClientRect().width / canvas.width;\n\n            return {\n                imageData,\n                x: canvasSpaceBounds.left * ratio,\n                y: canvasSpaceBounds.bottom * ratio,\n                width: canvasSpaceBounds.width * ratio,\n                height: canvasSpaceBounds.height * ratio\n            };\n        } finally {\n            gl.deleteFramebuffer(bufferInfo.framebuffer);\n        }\n    }\n\n    /**\n     * @typedef ColorExtraction\n     * @property {Uint8Array} data Raw pixel data for the drawable\n     * @property {int} width Drawable bounding box width\n     * @property {int} height Drawable bounding box height\n     * @property {object} color Color object with RGBA properties at picked location\n     */\n\n    /**\n     * Return drawable pixel data and color at a given position\n     * @param {int} x The client x coordinate of the picking location.\n     * @param {int} y The client y coordinate of the picking location.\n     * @param {int} radius The client radius to extract pixels with.\n     * @return {?ColorExtraction} Data about the picked color\n     */\n    extractColor (x, y, radius) {\n        this._doExitDrawRegion();\n\n        const scratchX = Math.round(this._nativeSize[0] * ((x / this._gl.canvas.clientWidth) - 0.5));\n        const scratchY = Math.round(-this._nativeSize[1] * ((y / this._gl.canvas.clientHeight) - 0.5));\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        const bounds = new Rectangle();\n        bounds.initFromBounds(scratchX - radius, scratchX + radius, scratchY - radius, scratchY + radius);\n\n        const pickX = scratchX - bounds.left;\n        const pickY = bounds.top - scratchY;\n\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        gl.clearColor(...this._backgroundColor4f);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, projection);\n\n        const data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n        gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n        const pixelBase = Math.floor(4 * ((pickY * bounds.width) + pickX));\n        const color = {\n            r: data[pixelBase],\n            g: data[pixelBase + 1],\n            b: data[pixelBase + 2],\n            a: data[pixelBase + 3]\n        };\n\n        if (this._debugCanvas) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n            const ctx = this._debugCanvas.getContext('2d');\n            const imageData = ctx.createImageData(bounds.width, bounds.height);\n            imageData.data.set(data);\n            ctx.putImageData(imageData, 0, 0);\n            ctx.strokeStyle = 'black';\n            ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n            ctx.rect(pickX - 4, pickY - 4, 8, 8);\n            ctx.fill();\n            ctx.stroke();\n        }\n\n        return {\n            data: data,\n            width: bounds.width,\n            height: bounds.height,\n            color: color\n        };\n    }\n\n    /**\n     * Get the candidate bounding box for a touching query.\n     * @param {int} drawableID ID for drawable of query.\n     * @return {?Rectangle} Rectangle bounds for touching query, or null.\n     */\n    _touchingBounds (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n\n        /** @todo remove this once URL-based skin setting is removed. */\n        if (!drawable.skin || !drawable.skin.getTexture([100, 100])) return null;\n\n        const bounds = drawable.getFastBounds();\n\n        // Limit queries to the stage size.\n        bounds.clamp(this._xLeft, this._xRight, this._yBottom, this._yTop);\n\n        // Use integer coordinates for queries - weird things happen\n        // when you provide float width/heights to gl.viewport and projection.\n        bounds.snapToInt();\n\n        if (bounds.width === 0 || bounds.height === 0) {\n            // No space to query.\n            return null;\n        }\n        return bounds;\n    }\n\n    /**\n     * Filter a list of candidates for a touching query into only those that\n     * could possibly intersect the given bounds.\n     * @param {int} drawableID - ID for drawable of query.\n     * @param {Array<int>} candidateIDs - Candidates for touching query.\n     * @return {?Array< {id, drawable, intersection} >} Filtered candidates with useful data.\n     */\n    _candidatesTouching (drawableID, candidateIDs) {\n        const bounds = this._touchingBounds(drawableID);\n        const result = [];\n        if (bounds === null) {\n            return result;\n        }\n        // iterate through the drawables list BACKWARDS - we want the top most item to be the first we check\n        for (let index = candidateIDs.length - 1; index >= 0; index--) {\n            const id = candidateIDs[index];\n            if (id !== drawableID) {\n                const drawable = this._allDrawables[id];\n                // Text bubbles aren't considered in \"touching\" queries\n                if (drawable.skin instanceof TextBubbleSkin) continue;\n                if (drawable.skin && drawable._visible) {\n                    // Update the CPU position data\n                    drawable.updateCPURenderAttributes();\n                    const candidateBounds = drawable.getFastBounds();\n\n                    // Push bounds out to integers. If a drawable extends out into half a pixel, that half-pixel still\n                    // needs to be tested. Plus, in some areas we construct another rectangle from the union of these,\n                    // and iterate over its pixels (width * height). Turns out that doesn't work so well when the\n                    // width/height aren't integers.\n                    candidateBounds.snapToInt();\n\n                    if (bounds.intersects(candidateBounds)) {\n                        result.push({\n                            id,\n                            drawable,\n                            intersection: Rectangle.intersect(bounds, candidateBounds)\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Helper to get the union bounds from a set of candidates returned from the above method\n     * @private\n     * @param {Array<object>} candidates info from _candidatesTouching\n     * @return {Rectangle} the outer bounding box union\n     */\n    _candidatesBounds (candidates) {\n        return candidates.reduce((memo, {intersection}) => {\n            if (!memo) {\n                return intersection;\n            }\n            // store the union of the two rectangles in our static rectangle instance\n            return Rectangle.union(memo, intersection, __candidatesBounds);\n        }, null);\n    }\n\n    /**\n     * Update a drawable's skin.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} skinId The skin to update to.\n     */\n    updateDrawableSkinId (drawableID, skinId) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.skin = this._allSkins[skinId];\n    }\n\n    /**\n     * Update a drawable's position.\n     * @param {number} drawableID The drawable's id.\n     * @param {Array.<number>} position The new position.\n     */\n    updateDrawablePosition (drawableID, position) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updatePosition(position);\n    }\n\n    /**\n     * Update a drawable's direction.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} direction A new direction.\n     */\n    updateDrawableDirection (drawableID, direction) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updateDirection(direction);\n    }\n\n    /**\n     * Update a drawable's scale.\n     * @param {number} drawableID The drawable's id.\n     * @param {Array.<number>} scale A new scale.\n     */\n    updateDrawableScale (drawableID, scale) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updateScale(scale);\n    }\n\n    /**\n     * Update a drawable's direction and scale together.\n     * @param {number} drawableID The drawable's id.\n     * @param {number} direction A new direction.\n     * @param {Array.<number>} scale A new scale.\n     */\n    updateDrawableDirectionScale (drawableID, direction, scale) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updateDirection(direction);\n        drawable.updateScale(scale);\n    }\n\n    /**\n     * Update a drawable's visibility.\n     * @param {number} drawableID The drawable's id.\n     * @param {boolean} visible Will the drawable be visible?\n     */\n    updateDrawableVisible (drawableID, visible) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updateVisible(visible);\n    }\n\n    /**\n     * Update a drawable's visual effect.\n     * @param {number} drawableID The drawable's id.\n     * @param {string} effectName The effect to change.\n     * @param {number} value A new effect value.\n     */\n    updateDrawableEffect (drawableID, effectName, value) {\n        const drawable = this._allDrawables[drawableID];\n        // TODO: https://github.com/LLK/scratch-vm/issues/2288\n        if (!drawable) return;\n        drawable.updateEffect(effectName, value);\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @deprecated Use specific updateDrawable* methods instead.\n     * @param {int} drawableID The ID of the Drawable to update.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateDrawableProperties (drawableID, properties) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            /**\n             * @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n             * Right now this happens so much on some projects that a warning or exception here can hang the browser.\n             */\n            return;\n        }\n        if ('skinId' in properties) {\n            this.updateDrawableSkinId(drawableID, properties.skinId);\n        }\n        drawable.updateProperties(properties);\n    }\n\n    /**\n     * Update the position object's x & y members to keep the drawable fenced in view.\n     * @param {int} drawableID - The ID of the Drawable to update.\n     * @param {Array.<number, number>} position to be fenced - An array of type [x, y]\n     * @return {Array.<number, number>} The fenced position as an array [x, y]\n     */\n    getFencedPositionOfDrawable (drawableID, position) {\n        let x = position[0];\n        let y = position[1];\n\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            // @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n            // Right now this happens so much on some projects that a warning or exception here can hang the browser.\n            return [x, y];\n        }\n\n        const dx = x - drawable._position[0];\n        const dy = y - drawable._position[1];\n        const aabb = drawable._skin.getFenceBounds(drawable, __fenceBounds);\n        const inset = Math.floor(Math.min(aabb.width, aabb.height) / 2);\n\n        const sx = this._xRight - Math.min(FENCE_WIDTH, inset);\n        if (aabb.right + dx < -sx) {\n            x = Math.ceil(drawable._position[0] - (sx + aabb.right));\n        } else if (aabb.left + dx > sx) {\n            x = Math.floor(drawable._position[0] + (sx - aabb.left));\n        }\n        const sy = this._yTop - Math.min(FENCE_WIDTH, inset);\n        if (aabb.top + dy < -sy) {\n            y = Math.ceil(drawable._position[1] - (sy + aabb.top));\n        } else if (aabb.bottom + dy > sy) {\n            y = Math.floor(drawable._position[1] + (sy - aabb.bottom));\n        }\n        return [x, y];\n    }\n\n    /**\n     * Clear a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     */\n    penClear (penSkinID) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.clear();\n    }\n\n    /**\n     * Draw a point on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n    penPoint (penSkinID, penAttributes, x, y) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.drawPoint(penAttributes, x, y);\n    }\n\n    /**\n     * Draw a line on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    penLine (penSkinID, penAttributes, x0, y0, x1, y1) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.drawLine(penAttributes, x0, y0, x1, y1);\n    }\n\n    /**\n     * Stamp a Drawable onto a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {int} stampID - the unique ID of the Drawable to use as the stamp.\n     */\n    penStamp (penSkinID, stampID) {\n        const stampDrawable = this._allDrawables[stampID];\n        if (!stampDrawable) {\n            return;\n        }\n\n        const bounds = this._touchingBounds(stampID);\n        if (!bounds) {\n            return;\n        }\n\n        this._doExitDrawRegion();\n\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, skin._framebuffer);\n\n        // Limit size of viewport to the bounds around the stamp Drawable and create the projection matrix for the draw.\n        gl.viewport(\n            (this._nativeSize[0] * 0.5) + bounds.left,\n            (this._nativeSize[1] * 0.5) - bounds.top,\n            bounds.width,\n            bounds.height\n        );\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        // Draw the stamped sprite onto the PenSkin's framebuffer.\n        this._drawThese([stampID], ShaderManager.DRAW_MODE.default, projection, {ignoreVisibility: true});\n        skin._silhouetteDirty = true;\n    }\n\n    /* ******\n     * Truly internal functions: these support the functions above.\n     ********/\n\n    /**\n     * Build geometry (vertex and index) buffers.\n     * @private\n     */\n    _createGeometry () {\n        const quad = {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    -0.5, -0.5,\n                    0.5, -0.5,\n                    -0.5, 0.5,\n                    -0.5, 0.5,\n                    0.5, -0.5,\n                    0.5, 0.5\n                ]\n            },\n            a_texCoord: {\n                numComponents: 2,\n                data: [\n                    1, 0,\n                    0, 0,\n                    1, 1,\n                    1, 1,\n                    0, 0,\n                    0, 1\n                ]\n            }\n        };\n        this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n\n    /**\n     * Respond to a change in the \"native\" rendering size. The native size is used by buffers which are fixed in size\n     * regardless of the size of the main render target. This includes the buffers used for queries such as picking and\n     * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.\n     * @param {object} event - The change event.\n     * @private\n     */\n    onNativeSizeChanged (event) {\n        const [width, height] = event.newSize;\n\n        const gl = this._gl;\n        const attachments = [\n            {format: gl.RGBA},\n            {format: gl.DEPTH_STENCIL}\n        ];\n\n        if (!this._pickBufferInfo) {\n            this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n        }\n\n        /** @todo should we create this on demand to save memory? */\n        // A 480x360 32-bpp buffer is 675 KiB.\n        if (this._queryBufferInfo) {\n            twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n        } else {\n            this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n        }\n    }\n\n    /**\n     * Enter a draw region.\n     *\n     * A draw region is where multiple draw operations are performed with the\n     * same GL state. WebGL performs poorly when it changes state like blend\n     * mode. Marking a collection of state values as a \"region\" the renderer\n     * can skip superfluous extra state calls when it is already in that\n     * region. Since one region may be entered from within another a exit\n     * handle can also be registered that is called when a new region is about\n     * to be entered to restore a common inbetween state.\n     *\n     * @param {any} regionId - id of the region to enter\n     * @param {function} enter - handle to call when first entering a region\n     * @param {function} exit - handle to call when leaving a region\n     */\n    enterDrawRegion (regionId, enter = regionId.enter, exit = regionId.exit) {\n        if (this._regionId !== regionId) {\n            this._doExitDrawRegion();\n            this._regionId = regionId;\n            enter();\n            this._exitRegion = exit;\n        }\n    }\n\n    /**\n     * Forcefully exit the current region returning to a common inbetween GL\n     * state.\n     */\n    _doExitDrawRegion () {\n        if (this._exitRegion !== null) {\n            this._exitRegion();\n        }\n        this._exitRegion = null;\n        this._regionId = null;\n    }\n\n    /**\n     * Draw a set of Drawables, by drawable ID\n     * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {module:twgl/m4.Mat4} projection The projection matrix to use.\n     * @param {object} [opts] Options for drawing\n     * @param {idFilterFunc} opts.filter An optional filter function.\n     * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.\n     * @param {int} opts.effectMask Bitmask for effects to allow\n     * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)\n     * @param {int} opts.framebufferWidth The width of the framebuffer being drawn onto. Defaults to \"native\" width\n     * @param {int} opts.framebufferHeight The height of the framebuffer being drawn onto. Defaults to \"native\" height\n     * @private\n     */\n    _drawThese (drawables, drawMode, projection, opts = {}) {\n\n        const gl = this._gl;\n        let currentShader = null;\n\n        const framebufferSpaceScaleDiffers = (\n            'framebufferWidth' in opts && 'framebufferHeight' in opts &&\n            opts.framebufferWidth !== this._nativeSize[0] && opts.framebufferHeight !== this._nativeSize[1]\n        );\n\n        const numDrawables = drawables.length;\n        for (let drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n            const drawableID = drawables[drawableIndex];\n\n            // If we have a filter, check whether the ID fails\n            if (opts.filter && !opts.filter(drawableID)) continue;\n\n            const drawable = this._allDrawables[drawableID];\n            /** @todo check if drawable is inside the viewport before anything else */\n\n            // Hidden drawables (e.g., by a \"hide\" block) are not drawn unless\n            // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).\n            if (!drawable.getVisible() && !opts.ignoreVisibility) continue;\n\n            // drawableScale is the \"framebuffer-pixel-space\" scale of the drawable, as percentages of the drawable's\n            // \"native size\" (so 100 = same as skin's \"native size\", 200 = twice \"native size\").\n            // If the framebuffer dimensions are the same as the stage's \"native\" size, there's no need to calculate it.\n            const drawableScale = framebufferSpaceScaleDiffers ? [\n                drawable.scale[0] * opts.framebufferWidth / this._nativeSize[0],\n                drawable.scale[1] * opts.framebufferHeight / this._nativeSize[1]\n            ] : drawable.scale;\n\n            // If the skin or texture isn't ready yet, skip it.\n            if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n\n            const uniforms = {};\n\n            let effectBits = drawable.enabledEffects;\n            effectBits &= Object.prototype.hasOwnProperty.call(opts, 'effectMask') ? opts.effectMask : effectBits;\n            const newShader = this._shaderManager.getShader(drawMode, effectBits);\n\n            // Manually perform region check. Do not create functions inside a\n            // loop.\n            if (this._regionId !== newShader) {\n                this._doExitDrawRegion();\n                this._regionId = newShader;\n\n                currentShader = newShader;\n                gl.useProgram(currentShader.program);\n                twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n                Object.assign(uniforms, {\n                    u_projectionMatrix: projection\n                });\n            }\n\n            Object.assign(uniforms,\n                drawable.skin.getUniforms(drawableScale),\n                drawable.getUniforms());\n\n            // Apply extra uniforms after the Drawable's, to allow overwriting.\n            if (opts.extraUniforms) {\n                Object.assign(uniforms, opts.extraUniforms);\n            }\n\n            if (uniforms.u_skin) {\n                twgl.setTextureParameters(\n                    gl, uniforms.u_skin, {\n                        minMag: drawable.skin.useNearest(drawableScale, drawable) ? gl.NEAREST : gl.LINEAR\n                    }\n                );\n            }\n\n            twgl.setUniforms(currentShader, uniforms);\n            twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n        }\n\n        this._regionId = null;\n    }\n\n    /**\n     * Get the convex hull points for a particular Drawable.\n     * To do this, calculate it based on the drawable's Silhouette.\n     * @param {int} drawableID The Drawable IDs calculate convex hull for.\n     * @return {Array<Array<number>>} points Convex hull points, as [[x, y], ...]\n     */\n    _getConvexHullPointsForDrawable (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n\n        const [width, height] = drawable.skin.size;\n        // No points in the hull if invisible or size is 0.\n        if (!drawable.getVisible() || width === 0 || height === 0) {\n            return [];\n        }\n\n        drawable.updateCPURenderAttributes();\n\n        /**\n         * Return the determinant of two vectors, the vector from A to B and the vector from A to C.\n         *\n         * The determinant is useful in this case to know if AC is counter-clockwise from AB.\n         * A positive value means that AC is counter-clockwise from AB. A negative value means AC is clockwise from AB.\n         *\n         * @param {Float32Array} A A 2d vector in space.\n         * @param {Float32Array} B A 2d vector in space.\n         * @param {Float32Array} C A 2d vector in space.\n         * @return {number} Greater than 0 if counter clockwise, less than if clockwise, 0 if all points are on a line.\n         */\n        const determinant = function (A, B, C) {\n            // AB = B - A\n            // AC = C - A\n            // det (AB BC) = AB0 * AC1 - AB1 * AC0\n            return (((B[0] - A[0]) * (C[1] - A[1])) - ((B[1] - A[1]) * (C[0] - A[0])));\n        };\n\n        // This algorithm for calculating the convex hull somewhat resembles the monotone chain algorithm.\n        // The main difference is that instead of sorting the points by x-coordinate, and y-coordinate in case of ties,\n        // it goes through them by y-coordinate in the outer loop and x-coordinate in the inner loop.\n        // This gives us \"left\" and \"right\" hulls, whereas the monotone chain algorithm gives \"top\" and \"bottom\" hulls.\n        // Adapted from https://github.com/LLK/scratch-flash/blob/dcbeeb59d44c3be911545dfe54d46a32404f8e69/src/scratch/ScratchCostume.as#L369-L413\n\n        const leftHull = [];\n        const rightHull = [];\n\n        // While convex hull algorithms usually push and pop values from the list of hull points,\n        // here, we keep indices for the \"last\" point in each array. Any points past these indices are ignored.\n        // This is functionally equivalent to pushing and popping from a \"stack\" of hull points.\n        let leftEndPointIndex = -1;\n        let rightEndPointIndex = -1;\n\n        const _pixelPos = twgl.v3.create();\n        const _effectPos = twgl.v3.create();\n\n        let currentPoint;\n\n        // *Not* Scratch Space-- +y is bottom\n        // Loop over all rows of pixels, starting at the top\n        for (let y = 0; y < height; y++) {\n            _pixelPos[1] = y / height;\n\n            // We start at the leftmost point, then go rightwards until we hit an opaque pixel\n            let x = 0;\n            for (; x < width; x++) {\n                _pixelPos[0] = x / width;\n                EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n                if (drawable.skin.isTouchingLinear(_effectPos)) {\n                    currentPoint = [x, y];\n                    break;\n                }\n            }\n\n            // If we managed to loop all the way through, there are no opaque pixels on this row. Go to the next one\n            if (x >= width) {\n                continue;\n            }\n\n            // Because leftEndPointIndex is initialized to -1, this is skipped for the first two rows.\n            // It runs only when there are enough points in the left hull to make at least one line.\n            // If appending the current point to the left hull makes a counter-clockwise turn,\n            // we want to append the current point. Otherwise, we decrement the index of the \"last\" hull point until the\n            // current point makes a counter-clockwise turn.\n            // This decrementing has the same effect as popping from the point list, but is hopefully faster.\n            while (leftEndPointIndex > 0) {\n                if (determinant(leftHull[leftEndPointIndex], leftHull[leftEndPointIndex - 1], currentPoint) > 0) {\n                    break;\n                } else {\n                    // leftHull.pop();\n                    --leftEndPointIndex;\n                }\n            }\n\n            // This has the same effect as pushing to the point list.\n            // This \"list head pointer\" coding style leaves excess points dangling at the end of the list,\n            // but that doesn't matter; we simply won't copy them over to the final hull.\n\n            // leftHull.push(currentPoint);\n            leftHull[++leftEndPointIndex] = currentPoint;\n\n            // Now we repeat the process for the right side, looking leftwards for a pixel.\n            for (x = width - 1; x >= 0; x--) {\n                _pixelPos[0] = x / width;\n                EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n                if (drawable.skin.isTouchingLinear(_effectPos)) {\n                    currentPoint = [x, y];\n                    break;\n                }\n            }\n\n            // Because we're coming at this from the right, it goes clockwise this time.\n            while (rightEndPointIndex > 0) {\n                if (determinant(rightHull[rightEndPointIndex], rightHull[rightEndPointIndex - 1], currentPoint) < 0) {\n                    break;\n                } else {\n                    --rightEndPointIndex;\n                }\n            }\n\n            rightHull[++rightEndPointIndex] = currentPoint;\n        }\n\n        // Start off \"hullPoints\" with the left hull points.\n        const hullPoints = leftHull;\n        // This is where we get rid of those dangling extra points.\n        hullPoints.length = leftEndPointIndex + 1;\n        // Add points from the right side in reverse order so all points are ordered clockwise.\n        for (let j = rightEndPointIndex; j >= 0; --j) {\n            hullPoints.push(rightHull[j]);\n        }\n\n        // Simplify boundary points using hull.js.\n        // TODO: Remove this; this algorithm already generates convex hulls.\n        return hull(hullPoints, Infinity);\n    }\n\n    /**\n     * Sample a \"final\" color from an array of drawables at a given scratch space.\n     * Will blend any alpha values with the drawables \"below\" it.\n     * @param {twgl.v3} vec Scratch Vector Space to sample\n     * @param {Array<Drawables>} drawables A list of drawables with the \"top most\"\n     *              drawable at index 0\n     * @param {Uint8ClampedArray} dst The color3b space to store the answer in.\n     * @return {Uint8ClampedArray} The dst vector with everything blended down.\n     */\n    static sampleColor3b (vec, drawables, dst) {\n        dst = dst || new Uint8ClampedArray(3);\n        dst.fill(0);\n        let blendAlpha = 1;\n        for (let index = 0; blendAlpha !== 0 && index < drawables.length; index++) {\n            /*\n            if (left > vec[0] || right < vec[0] ||\n                bottom > vec[1] || top < vec[0]) {\n                continue;\n            }\n            */\n            Drawable.sampleColor4b(vec, drawables[index].drawable, __blendColor);\n            // Equivalent to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n            dst[0] += __blendColor[0] * blendAlpha;\n            dst[1] += __blendColor[1] * blendAlpha;\n            dst[2] += __blendColor[2] * blendAlpha;\n            blendAlpha *= (1 - (__blendColor[3] / 255));\n        }\n        // Backdrop could be transparent, so we need to go to the \"clear color\" of the\n        // draw scene (white) as a fallback if everything was alpha\n        dst[0] += blendAlpha * 255;\n        dst[1] += blendAlpha * 255;\n        dst[2] += blendAlpha * 255;\n        return dst;\n    }\n\n    /**\n     * @callback RenderWebGL#snapshotCallback\n     * @param {string} dataURI Data URI of the snapshot of the renderer\n     */\n\n    /**\n     * @param {snapshotCallback} callback Function called in the next frame with the snapshot data\n     */\n    requestSnapshot (callback) {\n        this._snapshotCallbacks.push(callback);\n    }\n}\n\n// :3\nRenderWebGL.prototype.canHazPixels = RenderWebGL.prototype.extractDrawableScreenSpace;\n\n/**\n * Values for setUseGPU()\n * @enum {string}\n */\nRenderWebGL.UseGpuModes = {\n    /**\n     * Heuristically decide whether to use the GPU path, the CPU path, or a dynamic mixture of the two.\n     */\n    Automatic: 'Automatic',\n\n    /**\n     * Always use the GPU path.\n     */\n    ForceGPU: 'ForceGPU',\n\n    /**\n     * Always use the CPU path.\n     */\n    ForceCPU: 'ForceCPU'\n};\n\nmodule.exports = RenderWebGL;\n","const twgl = require('twgl.js');\n\nconst Skin = require('./Skin');\nconst {loadSvgString, serializeSvgToString} = require('scratch-svg-renderer');\nconst ShaderManager = require('./ShaderManager');\n\nconst MAX_TEXTURE_DIMENSION = 2048;\n\n/**\n * All scaled renderings of the SVG are stored in an array. The 1.0 scale of\n * the SVG is stored at the 8th index. The smallest possible 1 / 256 scale\n * rendering is stored at the 0th index.\n * @const {number}\n */\nconst INDEX_OFFSET = 8;\n\nclass SVGSkin extends Skin {\n    /**\n     * Create a new SVG skin.\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     * @constructor\n     * @extends Skin\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /** @type {RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {HTMLImageElement} */\n        this._svgImage = document.createElement('img');\n\n        /** @type {boolean} */\n        this._svgImageLoaded = false;\n\n        /** @type {Array<number>} */\n        this._size = [0, 0];\n\n        /** @type {HTMLCanvasElement} */\n        this._canvas = document.createElement('canvas');\n\n        /** @type {CanvasRenderingContext2D} */\n        this._context = this._canvas.getContext('2d');\n\n        /** @type {Array<WebGLTexture>} */\n        this._scaledMIPs = [];\n\n        /** @type {number} */\n        this._largestMIPScale = 0;\n\n        /**\n        * Ratio of the size of the SVG and the max size of the WebGL texture\n        * @type {Number}\n        */\n        this._maxTextureScale = 1;\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        this.resetMIPs();\n        super.dispose();\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this skin.\n     */\n    get size () {\n        return [this._size[0], this._size[1]];\n    }\n\n    useNearest (scale, drawable) {\n        // If the effect bits for mosaic, pixelate, whirl, or fisheye are set, use linear\n        if ((drawable.enabledEffects & (\n            ShaderManager.EFFECT_INFO.fisheye.mask |\n            ShaderManager.EFFECT_INFO.whirl.mask |\n            ShaderManager.EFFECT_INFO.pixelate.mask |\n            ShaderManager.EFFECT_INFO.mosaic.mask\n        )) !== 0) {\n            return false;\n        }\n\n        // We can't use nearest neighbor unless we are a multiple of 90 rotation\n        if (drawable._direction % 90 !== 0) {\n            return false;\n        }\n\n        // Because SVG skins' bounding boxes are currently not pixel-aligned, the idea here is to hide blurriness\n        // by using nearest-neighbor scaling if one screen-space pixel is \"close enough\" to one texture pixel.\n        // If the scale of the skin is very close to 100 (0.99999 variance is okay I guess)\n        // TODO: Make this check more precise. We should use nearest if there's less than one pixel's difference\n        // between the screen-space and texture-space sizes of the skin. Mipmaps make this harder because there are\n        // multiple textures (and hence multiple texture spaces) and we need to know which one to choose.\n        if (Math.abs(scale[0]) > 99 && Math.abs(scale[0]) < 101 &&\n            Math.abs(scale[1]) > 99 && Math.abs(scale[1]) < 101) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Create a MIP for a given scale.\n     * @param {number} scale - The relative size of the MIP\n     * @return {SVGMIP} An object that handles creating and updating SVG textures.\n     */\n    createMIP (scale) {\n        const [width, height] = this._size;\n        this._canvas.width = width * scale;\n        this._canvas.height = height * scale;\n        if (\n            this._canvas.width <= 0 ||\n            this._canvas.height <= 0 ||\n            // Even if the canvas at the current scale has a nonzero size, the image's dimensions are floored\n            // pre-scaling; e.g. if an image has a width of 0.4 and is being rendered at 3x scale, the canvas will have\n            // a width of 1, but the image's width will be rounded down to 0 on some browsers (Firefox) prior to being\n            // drawn at that scale, resulting in an IndexSizeError if we attempt to draw it.\n            this._svgImage.naturalWidth <= 0 ||\n            this._svgImage.naturalHeight <= 0\n        ) return super.getTexture();\n        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n        this._context.setTransform(scale, 0, 0, scale, 0, 0);\n        this._context.drawImage(this._svgImage, 0, 0);\n\n        // Pull out the ImageData from the canvas. ImageData speeds up\n        // updating Silhouette and is better handled by more browsers in\n        // regards to memory.\n        const textureData = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\n        const textureOptions = {\n            auto: false,\n            wrap: this._renderer.gl.CLAMP_TO_EDGE,\n            src: textureData,\n            premultiplyAlpha: true\n        };\n\n        const mip = twgl.createTexture(this._renderer.gl, textureOptions);\n\n        // Check if this is the largest MIP created so far. Currently, silhouettes only get scaled up.\n        if (this._largestMIPScale < scale) {\n            this._silhouette.update(textureData);\n            this._largestMIPScale = scale;\n        }\n\n        return mip;\n    }\n\n    updateSilhouette (scale = [100, 100]) {\n        // Ensure a silhouette exists.\n        this.getTexture(scale);\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    getTexture (scale) {\n        // The texture only ever gets uniform scale. Take the larger of the two axes.\n        const scaleMax = scale ? Math.max(Math.abs(scale[0]), Math.abs(scale[1])) : 100;\n        const requestedScale = Math.min(scaleMax / 100, this._maxTextureScale);\n\n        // Math.ceil(Math.log2(scale)) means we use the \"1x\" texture at (0.5, 1] scale,\n        // the \"2x\" texture at (1, 2] scale, the \"4x\" texture at (2, 4] scale, etc.\n        // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\n        // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\n        const mipLevel = Math.max(Math.ceil(Math.log2(requestedScale)) + INDEX_OFFSET, 0);\n        // Can't use bitwise stuff here because we need to handle negative exponents\n        const mipScale = Math.pow(2, mipLevel - INDEX_OFFSET);\n\n        if (this._svgImageLoaded && !this._scaledMIPs[mipLevel]) {\n            this._scaledMIPs[mipLevel] = this.createMIP(mipScale);\n        }\n\n        return this._scaledMIPs[mipLevel] || super.getTexture();\n    }\n\n    /**\n     * Do a hard reset of the existing MIPs by deleting them.\n     */\n    resetMIPs () {\n        this._scaledMIPs.forEach(oldMIP => this._renderer.gl.deleteTexture(oldMIP));\n        this._scaledMIPs.length = 0;\n        this._largestMIPScale = 0;\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided SVG data.\n     * @param {string} svgData - new SVG to use.\n     * @param {Array<number>} [rotationCenter] - Optional rotation center for the SVG. If not supplied, it will be\n     * calculated from the bounding box\n     * @fires Skin.event:WasAltered\n     */\n    setSVG (svgData, rotationCenter) {\n        const svgTag = loadSvgString(svgData);\n        const svgText = serializeSvgToString(svgTag, true /* shouldInjectFonts */);\n        this._svgImageLoaded = false;\n\n        const {x, y, width, height} = svgTag.viewBox.baseVal;\n        // While we're setting the size before the image is loaded, this doesn't cause the skin to appear with the wrong\n        // size for a few frames while the new image is loading, because we don't emit the `WasAltered` event, telling\n        // drawables using this skin to update, until the image is loaded.\n        // We need to do this because the VM reads the skin's `size` directly after calling `setSVG`.\n        // TODO: return a Promise so that the VM can read the skin's `size` after the image is loaded.\n        this._size[0] = width;\n        this._size[1] = height;\n\n        // If there is another load already in progress, replace the old onload to effectively cancel the old load\n        this._svgImage.onload = () => {\n            if (width === 0 || height === 0) {\n                super.setEmptyImageData();\n                return;\n            }\n\n            const maxDimension = Math.ceil(Math.max(width, height));\n            let testScale = 2;\n            for (testScale; maxDimension * testScale <= MAX_TEXTURE_DIMENSION; testScale *= 2) {\n                this._maxTextureScale = testScale;\n            }\n\n            this.resetMIPs();\n\n            if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();\n            // Compensate for viewbox offset.\n            // See https://github.com/LLK/scratch-render/pull/90.\n            this._rotationCenter[0] = rotationCenter[0] - x;\n            this._rotationCenter[1] = rotationCenter[1] - y;\n\n            this._svgImageLoaded = true;\n\n            this.emit(Skin.Events.WasAltered);\n        };\n\n        this._svgImage.src = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;\n    }\n\n}\n\nmodule.exports = SVGSkin;\n","const twgl = require('twgl.js');\n\n\nclass ShaderManager {\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for\n     * @constructor\n     */\n    constructor (gl) {\n        this._gl = gl;\n\n        /**\n         * The cache of all shaders compiled so far, filled on demand.\n         * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}\n         * @private\n         */\n        this._shaderCache = {};\n        for (const modeName in ShaderManager.DRAW_MODE) {\n            if (Object.prototype.hasOwnProperty.call(ShaderManager.DRAW_MODE, modeName)) {\n                this._shaderCache[modeName] = [];\n            }\n        }\n    }\n\n    /**\n     * Fetch the shader for a particular set of active effects.\n     * Build the shader if necessary.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The shader's program info.\n     */\n    getShader (drawMode, effectBits) {\n        const cache = this._shaderCache[drawMode];\n        if (drawMode === ShaderManager.DRAW_MODE.silhouette) {\n            // Silhouette mode isn't affected by these effects.\n            effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);\n        }\n        let shader = cache[effectBits];\n        if (!shader) {\n            shader = cache[effectBits] = this._buildShader(drawMode, effectBits);\n        }\n        return shader;\n    }\n\n    /**\n     * Build the shader for a particular set of active effects.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The new shader's program info.\n     * @private\n     */\n    _buildShader (drawMode, effectBits) {\n        const numEffects = ShaderManager.EFFECTS.length;\n\n        const defines = [\n            `#define DRAW_MODE_${drawMode}`\n        ];\n        for (let index = 0; index < numEffects; ++index) {\n            if ((effectBits & (1 << index)) !== 0) {\n                defines.push(`#define ENABLE_${ShaderManager.EFFECTS[index]}`);\n            }\n        }\n\n        const definesText = `${defines.join('\\n')}\\n`;\n\n        /* eslint-disable global-require */\n        const vsFullText = definesText + require('raw-loader!./shaders/sprite.vert');\n        const fsFullText = definesText + require('raw-loader!./shaders/sprite.frag');\n        /* eslint-enable global-require */\n\n        return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);\n    }\n}\n\n/**\n * @typedef {object} ShaderManager.Effect\n * @prop {int} mask - The bit in 'effectBits' representing the effect.\n * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range\n *   0..100 or -100..100) and maps it to a value useful to the shader. This\n *   mapping may not be reversible.\n * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.\n */\n\n/**\n * Mapping of each effect name to info about that effect.\n * @enum {ShaderManager.Effect}\n */\nShaderManager.EFFECT_INFO = {\n    /** Color effect */\n    color: {\n        uniformName: 'u_color',\n        mask: 1 << 0,\n        converter: x => (x / 200) % 1,\n        shapeChanges: false\n    },\n    /** Fisheye effect */\n    fisheye: {\n        uniformName: 'u_fisheye',\n        mask: 1 << 1,\n        converter: x => Math.max(0, (x + 100) / 100),\n        shapeChanges: true\n    },\n    /** Whirl effect */\n    whirl: {\n        uniformName: 'u_whirl',\n        mask: 1 << 2,\n        converter: x => -x * Math.PI / 180,\n        shapeChanges: true\n    },\n    /** Pixelate effect */\n    pixelate: {\n        uniformName: 'u_pixelate',\n        mask: 1 << 3,\n        converter: x => Math.abs(x) / 10,\n        shapeChanges: true\n    },\n    /** Mosaic effect */\n    mosaic: {\n        uniformName: 'u_mosaic',\n        mask: 1 << 4,\n        converter: x => {\n            x = Math.round((Math.abs(x) + 10) / 10);\n            /** @todo cap by Math.min(srcWidth, srcHeight) */\n            return Math.max(1, Math.min(x, 512));\n        },\n        shapeChanges: true\n    },\n    /** Brightness effect */\n    brightness: {\n        uniformName: 'u_brightness',\n        mask: 1 << 5,\n        converter: x => Math.max(-100, Math.min(x, 100)) / 100,\n        shapeChanges: false\n    },\n    /** Ghost effect */\n    ghost: {\n        uniformName: 'u_ghost',\n        mask: 1 << 6,\n        converter: x => 1 - (Math.max(0, Math.min(x, 100)) / 100),\n        shapeChanges: false\n    }\n};\n\n/**\n * The name of each supported effect.\n * @type {Array}\n */\nShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);\n\n/**\n * The available draw modes.\n * @readonly\n * @enum {string}\n */\nShaderManager.DRAW_MODE = {\n    /**\n     * Draw normally. Its output will use premultiplied alpha.\n     */\n    default: 'default',\n\n    /**\n     * Draw with non-premultiplied alpha. Useful for reading pixels from GL into an ImageData object.\n     */\n    straightAlpha: 'straightAlpha',\n\n    /**\n     * Draw a silhouette using a solid color.\n     */\n    silhouette: 'silhouette',\n\n    /**\n     * Draw only the parts of the drawable which match a particular color.\n     */\n    colorMask: 'colorMask',\n\n    /**\n     * Draw a line with caps.\n     */\n    line: 'line',\n\n    /**\n     * Draw the background in a certain color. Must sometimes be used instead of gl.clear.\n     */\n    background: 'background'\n};\n\nmodule.exports = ShaderManager;\n","/**\n * @fileoverview\n * A representation of a Skin's silhouette that can test if a point on the skin\n * renders a pixel where it is drawn.\n */\n\n/**\n * <canvas> element used to update Silhouette data from skin bitmap data.\n * @type {CanvasElement}\n */\nlet __SilhouetteUpdateCanvas;\n\n// Optimized Math.min and Math.max for integers;\n// taken from https://web.archive.org/web/20190716181049/http://guihaire.com/code/?p=549\nconst intMin = (i, j) => j ^ ((i ^ j) & ((i - j) >> 31));\nconst intMax = (i, j) => i ^ ((i ^ j) & ((i - j) >> 31));\n\n/**\n * Internal helper function (in hopes that compiler can inline).  Get a pixel\n * from silhouette data, or 0 if outside it's bounds.\n * @private\n * @param {Silhouette} silhouette - has data width and height\n * @param {number} x - x\n * @param {number} y - y\n * @return {number} Alpha value for x/y position\n */\nconst getPoint = ({_width: width, _height: height, _colorData: data}, x, y) => {\n    // 0 if outside bounds, otherwise read from data.\n    if (x >= width || y >= height || x < 0 || y < 0) {\n        return 0;\n    }\n    return data[(((y * width) + x) * 4) + 3];\n};\n\n/**\n * Memory buffers for doing 4 corner sampling for linear interpolation\n */\nconst __cornerWork = [\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4)\n];\n\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Multiply color values by alpha for proper blending.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nconst getColor4b = ({_width: width, _height: height, _colorData: data}, x, y, dst) => {\n    // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.\n    // (See github.com/LLK/scratch-render/blob/954cfff02b08069a082cbedd415c1fecd9b1e4fb/src/BitmapSkin.js#L88)\n    x = intMax(0, intMin(x, width - 1));\n    y = intMax(0, intMin(y, height - 1));\n\n    // 0 if outside bounds, otherwise read from data.\n    if (x >= width || y >= height || x < 0 || y < 0) {\n        return dst.fill(0);\n    }\n    const offset = ((y * width) + x) * 4;\n    // premultiply alpha\n    const alpha = data[offset + 3] / 255;\n    dst[0] = data[offset] * alpha;\n    dst[1] = data[offset + 1] * alpha;\n    dst[2] = data[offset + 2] * alpha;\n    dst[3] = data[offset + 3];\n    return dst;\n};\n\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * Do not multiply color values by alpha, as it has already been done.\n * @param {Silhouette} $0 The silhouette to sample.\n * @param {number} x X position of texture [0, width).\n * @param {number} y Y position of texture [0, height).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nconst getPremultipliedColor4b = ({_width: width, _height: height, _colorData: data}, x, y, dst) => {\n    // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.\n    x = intMax(0, intMin(x, width - 1));\n    y = intMax(0, intMin(y, height - 1));\n\n    const offset = ((y * width) + x) * 4;\n    dst[0] = data[offset];\n    dst[1] = data[offset + 1];\n    dst[2] = data[offset + 2];\n    dst[3] = data[offset + 3];\n    return dst;\n};\n\nclass Silhouette {\n    constructor () {\n        /**\n         * The width of the data representing the current skin data.\n         * @type {number}\n         */\n        this._width = 0;\n\n        /**\n         * The height of the data representing the current skin date.\n         * @type {number}\n         */\n        this._height = 0;\n\n        /**\n         * The data representing a skin's silhouette shape.\n         * @type {Uint8ClampedArray}\n         */\n        this._colorData = null;\n\n        // By default, silhouettes are assumed not to contain premultiplied image data,\n        // so when we get a color, we want to multiply it by its alpha channel.\n        // Point `_getColor` to the version of the function that multiplies.\n        this._getColor = getColor4b;\n\n        this.colorAtNearest = this.colorAtLinear = (_, dst) => dst.fill(0);\n    }\n\n    /**\n     * Update this silhouette with the bitmapData for a skin.\n     * @param {ImageData|HTMLCanvasElement|HTMLImageElement} bitmapData An image, canvas or other element that the skin\n     * @param {boolean} isPremultiplied True if the source bitmap data comes premultiplied (e.g. from readPixels).\n     * rendering can be queried from.\n     */\n    update (bitmapData, isPremultiplied = false) {\n        let imageData;\n        if (bitmapData instanceof ImageData) {\n            // If handed ImageData directly, use it directly.\n            imageData = bitmapData;\n            this._width = bitmapData.width;\n            this._height = bitmapData.height;\n        } else {\n            // Draw about anything else to our update canvas and poll image data\n            // from that.\n            const canvas = Silhouette._updateCanvas();\n            const width = this._width = canvas.width = bitmapData.width;\n            const height = this._height = canvas.height = bitmapData.height;\n            const ctx = canvas.getContext('2d');\n\n            if (!(width && height)) {\n                return;\n            }\n            ctx.clearRect(0, 0, width, height);\n            ctx.drawImage(bitmapData, 0, 0, width, height);\n            imageData = ctx.getImageData(0, 0, width, height);\n        }\n\n        if (isPremultiplied) {\n            this._getColor = getPremultipliedColor4b;\n        } else {\n            this._getColor = getColor4b;\n        }\n\n        this._colorData = imageData.data;\n        // delete our custom overriden \"uninitalized\" color functions\n        // let the prototype work for itself\n        delete this.colorAtNearest;\n        delete this.colorAtLinear;\n    }\n\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"nearest neighbor\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n    colorAtNearest (vec, dst) {\n        return this._getColor(\n            this,\n            Math.floor(vec[0] * (this._width - 1)),\n            Math.floor(vec[1] * (this._height - 1)),\n            dst\n        );\n    }\n\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"linear interpolation\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n    colorAtLinear (vec, dst) {\n        const x = vec[0] * (this._width - 1);\n        const y = vec[1] * (this._height - 1);\n\n        const x1D = x % 1;\n        const y1D = y % 1;\n        const x0D = 1 - x1D;\n        const y0D = 1 - y1D;\n\n        const xFloor = Math.floor(x);\n        const yFloor = Math.floor(y);\n\n        const x0y0 = this._getColor(this, xFloor, yFloor, __cornerWork[0]);\n        const x1y0 = this._getColor(this, xFloor + 1, yFloor, __cornerWork[1]);\n        const x0y1 = this._getColor(this, xFloor, yFloor + 1, __cornerWork[2]);\n        const x1y1 = this._getColor(this, xFloor + 1, yFloor + 1, __cornerWork[3]);\n\n        dst[0] = (x0y0[0] * x0D * y0D) + (x0y1[0] * x0D * y1D) + (x1y0[0] * x1D * y0D) + (x1y1[0] * x1D * y1D);\n        dst[1] = (x0y0[1] * x0D * y0D) + (x0y1[1] * x0D * y1D) + (x1y0[1] * x1D * y0D) + (x1y1[1] * x1D * y1D);\n        dst[2] = (x0y0[2] * x0D * y0D) + (x0y1[2] * x0D * y1D) + (x1y0[2] * x1D * y0D) + (x1y1[2] * x1D * y1D);\n        dst[3] = (x0y0[3] * x0D * y0D) + (x0y1[3] * x0D * y1D) + (x1y0[3] * x1D * y0D) + (x1y1[3] * x1D * y1D);\n\n        return dst;\n    }\n\n    /**\n     * Test if texture coordinate touches the silhouette using nearest neighbor.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} If the nearest pixel has an alpha value.\n     */\n    isTouchingNearest (vec) {\n        if (!this._colorData) return;\n        return getPoint(\n            this,\n            Math.floor(vec[0] * (this._width - 1)),\n            Math.floor(vec[1] * (this._height - 1))\n        ) > 0;\n    }\n\n    /**\n     * Test to see if any of the 4 pixels used in the linear interpolate touch\n     * the silhouette.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Any of the pixels have some alpha.\n     */\n    isTouchingLinear (vec) {\n        if (!this._colorData) return;\n        const x = Math.floor(vec[0] * (this._width - 1));\n        const y = Math.floor(vec[1] * (this._height - 1));\n        return getPoint(this, x, y) > 0 ||\n            getPoint(this, x + 1, y) > 0 ||\n            getPoint(this, x, y + 1) > 0 ||\n            getPoint(this, x + 1, y + 1) > 0;\n    }\n\n    /**\n     * Get the canvas element reused by Silhouettes to update their data with.\n     * @private\n     * @return {CanvasElement} A canvas to draw bitmap data to.\n     */\n    static _updateCanvas () {\n        if (typeof __SilhouetteUpdateCanvas === 'undefined') {\n            __SilhouetteUpdateCanvas = document.createElement('canvas');\n        }\n        return __SilhouetteUpdateCanvas;\n    }\n}\n\nmodule.exports = Silhouette;\n","const EventEmitter = require('events');\n\nconst twgl = require('twgl.js');\n\nconst RenderConstants = require('./RenderConstants');\nconst Silhouette = require('./Silhouette');\n\nclass Skin extends EventEmitter {\n    /**\n     * Create a Skin, which stores and/or generates textures for use in rendering.\n     * @param {int} id - The unique ID for this Skin.\n     * @constructor\n     */\n    constructor (id) {\n        super();\n\n        /** @type {int} */\n        this._id = id;\n\n        /** @type {Vec3} */\n        this._rotationCenter = twgl.v3.create(0, 0);\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The nominal (not necessarily current) size of the current skin.\n             * @type {Array<number>}\n             */\n            u_skinSize: [0, 0],\n\n            /**\n             * The actual WebGL texture object for the skin.\n             * @type {WebGLTexture}\n             */\n            u_skin: null\n        };\n\n        /**\n         * A silhouette to store touching data, skins are responsible for keeping it up to date.\n         * @private\n         */\n        this._silhouette = new Silhouette();\n\n        this.setMaxListeners(RenderConstants.SKIN_SHARE_SOFT_LIMIT);\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        this._id = RenderConstants.ID_NONE;\n    }\n\n    /**\n     * @return {int} the unique ID for this Skin.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {Vec3} the origin, in object space, about which this Skin should rotate.\n     */\n    get rotationCenter () {\n        return this._rotationCenter;\n    }\n\n    /**\n     * @abstract\n     * @return {Array<number>} the \"native\" size, in texels, of this skin.\n     */\n    get size () {\n        return [0, 0];\n    }\n\n    /**\n     * Should this skin's texture be filtered with nearest-neighbor or linear interpolation at the given scale?\n     * @param {?Array<Number>} scale The screen-space X and Y scaling factors at which this skin's texture will be\n     * displayed, as percentages (100 means 1 \"native size\" unit is 1 screen pixel; 200 means 2 screen pixels, etc).\n     * @param {Drawable} drawable The drawable that this skin's texture will be applied to.\n     * @return {boolean} True if this skin's texture, as returned by {@link getTexture}, should be filtered with\n     * nearest-neighbor interpolation.\n     */\n    // eslint-disable-next-line no-unused-vars\n    useNearest (scale, drawable) {\n        return true;\n    }\n\n    /**\n     * Get the center of the current bounding box\n     * @return {Array<number>} the center of the current bounding box\n     */\n    calculateRotationCenter () {\n        return [this.size[0] / 2, this.size[1] / 2];\n    }\n\n    /**\n     * @abstract\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        return this._emptyImageTexture;\n    }\n\n    /**\n     * Get the bounds of the drawable for determining its fenced position.\n     * @param {Array<number>} drawable - The Drawable instance this skin is using.\n     * @param {?Rectangle} result - Optional destination for bounds calculation.\n     * @return {!Rectangle} The drawable's bounds. For compatibility with Scratch 2, we always use getAABB.\n     */\n    getFenceBounds (drawable, result) {\n        return drawable.getAABB(result);\n    }\n\n    /**\n     * Update and returns the uniforms for this skin.\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering with this Skin.\n     */\n    getUniforms (scale) {\n        this._uniforms.u_skin = this.getTexture(scale);\n        this._uniforms.u_skinSize = this.size;\n        return this._uniforms;\n    }\n\n    /**\n     * If the skin defers silhouette operations until the last possible minute,\n     * this will be called before isTouching uses the silhouette.\n     * @abstract\n     */\n    updateSilhouette () {}\n\n    /**\n     * Set this skin's texture to the given image.\n     * @param {ImageData|HTMLCanvasElement} textureData - The canvas or image data to set the texture to.\n     */\n    _setTexture (textureData) {\n        const gl = this._renderer.gl;\n\n        gl.bindTexture(gl.TEXTURE_2D, this._texture);\n        // Premultiplied alpha is necessary for proper blending.\n        // See http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureData);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\n        this._silhouette.update(textureData);\n    }\n\n    /**\n     * Set the contents of this skin to an empty skin.\n     * @fires Skin.event:WasAltered\n     */\n    setEmptyImageData () {\n        // Free up the current reference to the _texture\n        this._texture = null;\n\n        if (!this._emptyImageData) {\n            // Create a transparent pixel\n            this._emptyImageData = new ImageData(1, 1);\n\n            // Create a new texture and update the silhouette\n            const gl = this._renderer.gl;\n\n            const textureOptions = {\n                auto: true,\n                wrap: gl.CLAMP_TO_EDGE,\n                src: this._emptyImageData\n            };\n\n            // Note: we're using _emptyImageTexture here instead of _texture\n            // so that we can cache this empty texture for later use as needed.\n            // this._texture can get modified by other skins (e.g. BitmapSkin\n            // and SVGSkin, so we can't use that same field for caching)\n            this._emptyImageTexture = twgl.createTexture(gl, textureOptions);\n        }\n\n        this._rotationCenter[0] = 0;\n        this._rotationCenter[1] = 0;\n\n        this._silhouette.update(this._emptyImageData);\n        this.emit(Skin.Events.WasAltered);\n    }\n\n    /**\n     * Does this point touch an opaque or translucent point on this skin?\n     * Nearest Neighbor version\n     * The caller is responsible for ensuring this skin's silhouette is up-to-date.\n     * @see updateSilhouette\n     * @see Drawable.updateCPURenderAttributes\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Did it touch?\n     */\n    isTouchingNearest (vec) {\n        return this._silhouette.isTouchingNearest(vec);\n    }\n\n    /**\n     * Does this point touch an opaque or translucent point on this skin?\n     * Linear Interpolation version\n     * The caller is responsible for ensuring this skin's silhouette is up-to-date.\n     * @see updateSilhouette\n     * @see Drawable.updateCPURenderAttributes\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Did it touch?\n     */\n    isTouchingLinear (vec) {\n        return this._silhouette.isTouchingLinear(vec);\n    }\n\n}\n\n/**\n * These are the events which can be emitted by instances of this class.\n * @enum {string}\n */\nSkin.Events = {\n    /**\n     * Emitted when anything about the Skin has been altered, such as the appearance or rotation center.\n     * @event Skin.event:WasAltered\n     */\n    WasAltered: 'WasAltered'\n};\n\nmodule.exports = Skin;\n","const twgl = require('twgl.js');\n\nconst TextWrapper = require('./util/text-wrapper');\nconst CanvasMeasurementProvider = require('./util/canvas-measurement-provider');\nconst Skin = require('./Skin');\n\nconst BubbleStyle = {\n    MAX_LINE_WIDTH: 170, // Maximum width, in Scratch pixels, of a single line of text\n\n    MIN_WIDTH: 50, // Minimum width, in Scratch pixels, of a text bubble\n    STROKE_WIDTH: 4, // Thickness of the stroke around the bubble. Only half's visible because it's drawn under the fill\n    PADDING: 10, // Padding around the text area\n    CORNER_RADIUS: 16, // Radius of the rounded corners\n    TAIL_HEIGHT: 12, // Height of the speech bubble's \"tail\". Probably should be a constant.\n\n    FONT: 'Helvetica', // Font to render the text with\n    FONT_SIZE: 14, // Font size, in Scratch pixels\n    FONT_HEIGHT_RATIO: 0.9, // Height, in Scratch pixels, of the text, as a proportion of the font's size\n    LINE_HEIGHT: 16, // Spacing between each line of text\n\n    COLORS: {\n        BUBBLE_FILL: 'white',\n        BUBBLE_STROKE: 'rgba(0, 0, 0, 0.15)',\n        TEXT_FILL: '#575E75'\n    }\n};\n\nclass TextBubbleSkin extends Skin {\n    /**\n     * Create a new text bubble skin.\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     * @constructor\n     * @extends Skin\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /** @type {RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {HTMLCanvasElement} */\n        this._canvas = document.createElement('canvas');\n\n        /** @type {Array<number>} */\n        this._size = [0, 0];\n\n        /** @type {number} */\n        this._renderedScale = 0;\n\n        /** @type {Array<string>} */\n        this._lines = [];\n\n        /** @type {object} */\n        this._textAreaSize = {width: 0, height: 0};\n\n        /** @type {string} */\n        this._bubbleType = '';\n\n        /** @type {boolean} */\n        this._pointsLeft = false;\n\n        /** @type {boolean} */\n        this._textDirty = true;\n\n        /** @type {boolean} */\n        this._textureDirty = true;\n\n        this.measurementProvider = new CanvasMeasurementProvider(this._canvas.getContext('2d'));\n        this.textWrapper = new TextWrapper(this.measurementProvider);\n\n        this._restyleCanvas();\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        if (this._texture) {\n            this._renderer.gl.deleteTexture(this._texture);\n            this._texture = null;\n        }\n        this._canvas = null;\n        super.dispose();\n    }\n\n    /**\n     * @return {Array<number>} the dimensions, in Scratch units, of this skin.\n     */\n    get size () {\n        if (this._textDirty) {\n            this._reflowLines();\n        }\n        return this._size;\n    }\n\n    /**\n     * Set parameters for this text bubble.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     */\n    setTextBubble (type, text, pointsLeft) {\n        this._text = text;\n        this._bubbleType = type;\n        this._pointsLeft = pointsLeft;\n\n        this._textDirty = true;\n        this._textureDirty = true;\n        this.emit(Skin.Events.WasAltered);\n    }\n\n    /**\n     * Re-style the canvas after resizing it. This is necessary to ensure proper text measurement.\n     */\n    _restyleCanvas () {\n        this._canvas.getContext('2d').font = `${BubbleStyle.FONT_SIZE}px ${BubbleStyle.FONT}, sans-serif`;\n    }\n\n    /**\n     * Update the array of wrapped lines and the text dimensions.\n     */\n    _reflowLines () {\n        this._lines = this.textWrapper.wrapText(BubbleStyle.MAX_LINE_WIDTH, this._text);\n\n        // Measure width of longest line to avoid extra-wide bubbles\n        let longestLineWidth = 0;\n        for (const line of this._lines) {\n            longestLineWidth = Math.max(longestLineWidth, this.measurementProvider.measureText(line));\n        }\n\n        // Calculate the canvas-space sizes of the padded text area and full text bubble\n        const paddedWidth = Math.max(longestLineWidth, BubbleStyle.MIN_WIDTH) + (BubbleStyle.PADDING * 2);\n        const paddedHeight = (BubbleStyle.LINE_HEIGHT * this._lines.length) + (BubbleStyle.PADDING * 2);\n\n        this._textAreaSize.width = paddedWidth;\n        this._textAreaSize.height = paddedHeight;\n\n        this._size[0] = paddedWidth + BubbleStyle.STROKE_WIDTH;\n        this._size[1] = paddedHeight + BubbleStyle.STROKE_WIDTH + BubbleStyle.TAIL_HEIGHT;\n\n        this._textDirty = false;\n    }\n\n    /**\n     * Render this text bubble at a certain scale, using the current parameters, to the canvas.\n     * @param {number} scale The scale to render the bubble at\n     */\n    _renderTextBubble (scale) {\n        const ctx = this._canvas.getContext('2d');\n\n        if (this._textDirty) {\n            this._reflowLines();\n        }\n\n        // Calculate the canvas-space sizes of the padded text area and full text bubble\n        const paddedWidth = this._textAreaSize.width;\n        const paddedHeight = this._textAreaSize.height;\n\n        // Resize the canvas to the correct screen-space size\n        this._canvas.width = Math.ceil(this._size[0] * scale);\n        this._canvas.height = Math.ceil(this._size[1] * scale);\n        this._restyleCanvas();\n\n        // Reset the transform before clearing to ensure 100% clearage\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\n        ctx.scale(scale, scale);\n        ctx.translate(BubbleStyle.STROKE_WIDTH * 0.5, BubbleStyle.STROKE_WIDTH * 0.5);\n\n        // If the text bubble points leftward, flip the canvas\n        ctx.save();\n        if (this._pointsLeft) {\n            ctx.scale(-1, 1);\n            ctx.translate(-paddedWidth, 0);\n        }\n\n        // Draw the bubble's rounded borders\n        ctx.beginPath();\n        ctx.moveTo(BubbleStyle.CORNER_RADIUS, paddedHeight);\n        ctx.arcTo(0, paddedHeight, 0, paddedHeight - BubbleStyle.CORNER_RADIUS, BubbleStyle.CORNER_RADIUS);\n        ctx.arcTo(0, 0, paddedWidth, 0, BubbleStyle.CORNER_RADIUS);\n        ctx.arcTo(paddedWidth, 0, paddedWidth, paddedHeight, BubbleStyle.CORNER_RADIUS);\n        ctx.arcTo(paddedWidth, paddedHeight, paddedWidth - BubbleStyle.CORNER_RADIUS, paddedHeight,\n            BubbleStyle.CORNER_RADIUS);\n\n        // Translate the canvas so we don't have to do a bunch of width/height arithmetic\n        ctx.save();\n        ctx.translate(paddedWidth - BubbleStyle.CORNER_RADIUS, paddedHeight);\n\n        // Draw the bubble's \"tail\"\n        if (this._bubbleType === 'say') {\n            // For a speech bubble, draw one swoopy thing\n            ctx.bezierCurveTo(0, 4, 4, 8, 4, 10);\n            ctx.arcTo(4, 12, 2, 12, 2);\n            ctx.bezierCurveTo(-1, 12, -11, 8, -16, 0);\n\n            ctx.closePath();\n        } else {\n            // For a thinking bubble, draw a partial circle attached to the bubble...\n            ctx.arc(-16, 0, 4, 0, Math.PI);\n\n            ctx.closePath();\n\n            // and two circles detached from it\n            ctx.moveTo(-7, 7.25);\n            ctx.arc(-9.25, 7.25, 2.25, 0, Math.PI * 2);\n\n            ctx.moveTo(0, 9.5);\n            ctx.arc(-1.5, 9.5, 1.5, 0, Math.PI * 2);\n        }\n\n        // Un-translate the canvas and fill + stroke the text bubble\n        ctx.restore();\n\n        ctx.fillStyle = BubbleStyle.COLORS.BUBBLE_FILL;\n        ctx.strokeStyle = BubbleStyle.COLORS.BUBBLE_STROKE;\n        ctx.lineWidth = BubbleStyle.STROKE_WIDTH;\n\n        ctx.stroke();\n        ctx.fill();\n\n        // Un-flip the canvas if it was flipped\n        ctx.restore();\n\n        // Draw each line of text\n        ctx.fillStyle = BubbleStyle.COLORS.TEXT_FILL;\n        ctx.font = `${BubbleStyle.FONT_SIZE}px ${BubbleStyle.FONT}, sans-serif`;\n        const lines = this._lines;\n        for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {\n            const line = lines[lineNumber];\n            ctx.fillText(\n                line,\n                BubbleStyle.PADDING,\n                BubbleStyle.PADDING + (BubbleStyle.LINE_HEIGHT * lineNumber) +\n                    (BubbleStyle.FONT_HEIGHT_RATIO * BubbleStyle.FONT_SIZE)\n            );\n        }\n\n        this._renderedScale = scale;\n    }\n\n    updateSilhouette (scale = [100, 100]) {\n        // Ensure a silhouette exists.\n        this.getTexture(scale);\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    getTexture (scale) {\n        // The texture only ever gets uniform scale. Take the larger of the two axes.\n        const scaleMax = scale ? Math.max(Math.abs(scale[0]), Math.abs(scale[1])) : 100;\n        const requestedScale = scaleMax / 100;\n\n        // If we already rendered the text bubble at this scale, we can skip re-rendering it.\n        if (this._textureDirty || this._renderedScale !== requestedScale) {\n            this._renderTextBubble(requestedScale);\n            this._textureDirty = false;\n\n            const context = this._canvas.getContext('2d');\n            const textureData = context.getImageData(0, 0, this._canvas.width, this._canvas.height);\n\n            const gl = this._renderer.gl;\n\n            if (this._texture === null) {\n                const textureOptions = {\n                    auto: false,\n                    wrap: gl.CLAMP_TO_EDGE\n                };\n\n                this._texture = twgl.createTexture(gl, textureOptions);\n            }\n\n            this._setTexture(textureData);\n        }\n\n        return this._texture;\n    }\n}\n\nmodule.exports = TextBubbleSkin;\n","const RenderWebGL = require('./RenderWebGL');\n\n/**\n * Export for NPM & Node.js\n * @type {RenderWebGL}\n */\nmodule.exports = RenderWebGL;\n","class CanvasMeasurementProvider {\n    /**\n     * @param {CanvasRenderingContext2D} ctx - provides a canvas rendering context\n     * with 'font' set to the text style of the text to be wrapped.\n     */\n    constructor (ctx) {\n        this._ctx = ctx;\n        this._cache = {};\n    }\n\n\n    // We don't need to set up or tear down anything here. Should these be removed altogether?\n\n    /**\n     * Called by the TextWrapper before a batch of zero or more calls to measureText().\n     */\n    beginMeasurementSession () {\n        \n    }\n\n    /**\n     * Called by the TextWrapper after a batch of zero or more calls to measureText().\n     */\n    endMeasurementSession () {\n        \n    }\n\n    /**\n     * Measure a whole string as one unit.\n     * @param {string} text - the text to measure.\n     * @returns {number} - the length of the string.\n     */\n    measureText (text) {\n        if (!this._cache[text]) {\n            this._cache[text] = this._ctx.measureText(text).width;\n        }\n        return this._cache[text];\n    }\n}\n\nmodule.exports = CanvasMeasurementProvider;\n","/**\n * Converts an RGB color value to HSV. Conversion formula\n * adapted from http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv.\n * Assumes r, g, and b are in the range [0, 255] and\n * returns h, s, and v in the range [0, 1].\n *\n * @param   {Array<number>} rgb   The RGB color value\n * @param   {number}        rgb.r The red color value\n * @param   {number}        rgb.g The green color value\n * @param   {number}        rgb.b The blue color value\n * @param   {Array<number>} dst   The array to store the HSV values in\n * @return  {Array<number>}       The `dst` array passed in\n */\nconst rgbToHsv = ([r, g, b], dst) => {\n    let K = 0.0;\n\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    let tmp = 0;\n\n    if (g < b) {\n        tmp = g;\n        g = b;\n        b = tmp;\n\n        K = -1;\n    }\n\n    if (r < g) {\n        tmp = r;\n        r = g;\n        g = tmp;\n\n        K = (-2 / 6) - K;\n    }\n\n    const chroma = r - Math.min(g, b);\n    const h = Math.abs(K + ((g - b) / ((6 * chroma) + Number.EPSILON)));\n    const s = chroma / (r + Number.EPSILON);\n    const v = r;\n\n    dst[0] = h;\n    dst[1] = s;\n    dst[2] = v;\n\n    return dst;\n};\n\n/**\n * Converts an HSV color value to RGB. Conversion formula\n * adapted from https://gist.github.com/mjackson/5311256.\n * Assumes h, s, and v are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param   {Array<number>}                hsv The HSV color value\n * @param   {number}                       hsv.h     The hue\n * @param   {number}                       hsv.s     The saturation\n * @param   {number}                       hsv.v     The value\n * @param   {Uint8Array|Uint8ClampedArray} dst The array to store the RGB values in\n * @return  {Uint8Array|Uint8ClampedArray}     The `dst` array passed in\n */\nconst hsvToRgb = ([h, s, v], dst) => {\n    if (s === 0) {\n        dst[0] = dst[1] = dst[2] = (v * 255) + 0.5;\n        return dst;\n    }\n\n    // keep hue in [0,1) so the `switch(i)` below only needs 6 cases (0-5)\n    h %= 1;\n    const i = (h * 6) | 0;\n    const f = (h * 6) - i;\n    const p = v * (1 - s);\n    const q = v * (1 - (s * f));\n    const t = v * (1 - (s * (1 - f)));\n\n    let r = 0;\n    let g = 0;\n    let b = 0;\n\n    switch (i) {\n    case 0: r = v; g = t; b = p; break;\n    case 1: r = q; g = v; b = p; break;\n    case 2: r = p; g = v; b = t; break;\n    case 3: r = p; g = q; b = v; break;\n    case 4: r = t; g = p; b = v; break;\n    case 5: r = v; g = p; b = q; break;\n    }\n\n    // Add 0.5 in order to round. Setting integer TypedArray elements implicitly floors.\n    dst[0] = (r * 255) + 0.5;\n    dst[1] = (g * 255) + 0.5;\n    dst[2] = (b * 255) + 0.5;\n    return dst;\n};\n\nmodule.exports = {rgbToHsv, hsvToRgb};\n","const minilog = require('minilog');\nminilog.enable();\n\nmodule.exports = minilog('scratch-render');\n","const LineBreaker = require('!ify-loader!linebreak');\nconst GraphemeBreaker = require('!ify-loader!grapheme-breaker');\n\n/**\n * Tell this text wrapper to use a specific measurement provider.\n * @typedef {object} MeasurementProvider - the new measurement provider.\n * @property {Function} beginMeasurementSession - this will be called before a batch of measurements are made.\n *      Optionally, this function may return an object to be provided to the endMeasurementSession function.\n * @property {Function} measureText - this will be called each time a piece of text must be measured.\n * @property {Function} endMeasurementSession - this will be called after a batch of measurements is finished.\n *      It will be passed whatever value beginMeasurementSession returned, if any.\n */\n\n/**\n * Utility to wrap text across several lines, respecting Unicode grapheme clusters and, when possible, Unicode line\n * break opportunities.\n * Reference material:\n * - Unicode Standard Annex #14: http://unicode.org/reports/tr14/\n * - Unicode Standard Annex #29: http://unicode.org/reports/tr29/\n * - \"JavaScript has a Unicode problem\" by Mathias Bynens: https://mathiasbynens.be/notes/javascript-unicode\n */\nclass TextWrapper {\n    /**\n     * Construct a text wrapper which will measure text using the specified measurement provider.\n     * @param {MeasurementProvider} measurementProvider - a helper object to provide text measurement services.\n     */\n    constructor (measurementProvider) {\n        this._measurementProvider = measurementProvider;\n        this._cache = {};\n    }\n\n    /**\n     * Wrap the provided text into lines restricted to a maximum width. See Unicode Standard Annex (UAX) #14.\n     * @param {number} maxWidth - the maximum allowed width of a line.\n     * @param {string} text - the text to be wrapped. Will be split on whitespace.\n     * @returns {Array.<string>} an array containing the wrapped lines of text.\n     */\n    wrapText (maxWidth, text) {\n        // Normalize to canonical composition (see Unicode Standard Annex (UAX) #15)\n        text = text.normalize();\n\n        const cacheKey = `${maxWidth}-${text}`;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n\n        const measurementSession = this._measurementProvider.beginMeasurementSession();\n\n        const breaker = new LineBreaker(text);\n        let lastPosition = 0;\n        let nextBreak;\n        let currentLine = null;\n        const lines = [];\n\n        while ((nextBreak = breaker.nextBreak())) {\n            const word = text.slice(lastPosition, nextBreak.position).replace(/\\n+$/, '');\n\n            let proposedLine = (currentLine || '').concat(word);\n            let proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n\n            if (proposedLineWidth > maxWidth) {\n                // The next word won't fit on this line. Will it fit on a line by itself?\n                const wordWidth = this._measurementProvider.measureText(word);\n                if (wordWidth > maxWidth) {\n                    // The next word can't even fit on a line by itself. Consume it one grapheme cluster at a time.\n                    let lastCluster = 0;\n                    let nextCluster;\n                    while (lastCluster !== (nextCluster = GraphemeBreaker.nextBreak(word, lastCluster))) {\n                        const cluster = word.substring(lastCluster, nextCluster);\n                        proposedLine = (currentLine || '').concat(cluster);\n                        proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n                        if ((currentLine === null) || (proposedLineWidth <= maxWidth)) {\n                            // first cluster of a new line or the cluster fits\n                            currentLine = proposedLine;\n                        } else {\n                            // no more can fit\n                            lines.push(currentLine);\n                            currentLine = cluster;\n                        }\n                        lastCluster = nextCluster;\n                    }\n                } else {\n                    // The next word can fit on the next line. Finish the current line and move on.\n                    if (currentLine !== null) lines.push(currentLine);\n                    currentLine = word;\n                }\n            } else {\n                // The next word fits on this line. Just keep going.\n                currentLine = proposedLine;\n            }\n\n            // Did we find a \\n or similar?\n            if (nextBreak.required) {\n                if (currentLine !== null) lines.push(currentLine);\n                currentLine = null;\n            }\n\n            lastPosition = nextBreak.position;\n        }\n\n        currentLine = currentLine || '';\n        if (currentLine.length > 0 || lines.length === 0) {\n            lines.push(currentLine);\n        }\n\n        this._cache[cacheKey] = lines;\n        this._measurementProvider.endMeasurementSession(measurementSession);\n        return lines;\n    }\n}\n\nmodule.exports = TextWrapper;\n","module.exports = require(\"events\");","module.exports = require(\"hull.js\");","module.exports = require(\"scratch-svg-renderer\");","module.exports = require(\"stream\");","module.exports = require(\"twgl.js\");","module.exports = require(\"util\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;;AACA;;;;;;AAMA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAWA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AA7DA;AACA;AACA;;;AAgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AA/GA;AACA;AAkHA;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAqCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAvgBA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AA6eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;AC7tBA;;;;;;AAMA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;;;;;;;AAOA;AACA;AACA;AAFA;AACA;AAIA;;;;AAIA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;;;;AAHA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AAFA;AADA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AA2DA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;;;AAxOA;AACA;AACA;;;;AApFA;AACA;AA4TA;;;;;;;;;;;;;;;;;;AC7VA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAmCA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;AAxCA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAoBA;;;;;;;;;;;;;;ACnMA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AARA;AAjBA;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AAOA;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAKA;;;;;AAKA;AACA;AAEA;;;;;;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtFA;AAuFA;AACA;AACA;;;;;;;;;AAcA;;;;;;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAcA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AAFA;AAWA;AACA;AACA;AAFA;AAZA;AAwBA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAcA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AAFA;AAAA;AAAA;AAIA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAmCA;;;;;AAKA;;;AAGA;AACA;AACA;;;AA5uDA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AAmSA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AA05CA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AA32DA;AACA;AAy3DA;AACA;AACA;AADA;AACA;AACA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AAdA;AACA;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5+DA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AA/BA;AAgCA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;AAOA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AArKA;AACA;AACA;;;;AAvDA;AACA;AA6NA;;;;;;;;;;;;;;;;;;AC9OA;AACA;AAEA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;AASA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAhDA;AACA;AAuDA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AA7BA;AACA;AA+BA;;;;;;;;;;;;;;;;;;AC1LA;;;;;;AAMA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAMA;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AAKA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;AAKA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;;;;AAIA;AACA;AACA;AAtCA;AAuCA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;AAsBA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;;;AA1JA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;AA1EA;AACA;AAsNA;;;;;;AAIA;AACA;;;;AAIA;AALA;AACA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAdA;AACA;AAoBA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAqCA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAUA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA/LA;AACA;AACA;AACA;AACA;AACA;;;;AAnEA;AACA;AA+PA;;;;;;;;;;;;;;AC3RA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;ACNA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;AAGA;AACA;AAGA;;;;;;AAGA;AACA;AAGA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;ACxCA;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AANA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;;;;;;;AAQA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;AC/GA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}